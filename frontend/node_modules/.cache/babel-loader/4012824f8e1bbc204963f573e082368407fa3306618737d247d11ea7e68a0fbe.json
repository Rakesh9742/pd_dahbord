{"ast":null,"code":"import { memo as e, useMemo as o, useState as i, useCallback as n, createElement as t, forwardRef as r, Fragment as a, useRef as l, useEffect as s } from \"react\";\nimport { curveFromProp as u, useValueFormatter as d, useMotionConfig as c, useAnimatedPath as h, getLabelGenerator as f, DotsItem as p, Container as v, useDimensions as b, CartesianMarkers as g, bindDefs as m, SvgWrapper as y, ResponsiveWrapper as x, getRelativeCursor as M, isCursorInRect as C, mergeRefs as S } from \"@nivo/core\";\nimport { defaultAxisProps as B, Grid as w, Axes as T, renderGridLinesToCanvas as k, renderAxesToCanvas as W } from \"@nivo/axes\";\nimport { BoxLegendSvg as L, renderLegendToCanvas as D } from \"@nivo/legends\";\nimport { BasicTooltip as I, TableTooltip as F, Chip as E, useTooltip as G, Crosshair as H } from \"@nivo/tooltip\";\nimport { line as P, area as R } from \"d3-shape\";\nimport O from \"lodash/uniqueId.js\";\nimport { useTheme as z } from \"@nivo/theming\";\nimport { useOrdinalColorScale as A, useInheritedColor as V } from \"@nivo/colors\";\nimport { computeXYScalesForSeries as Y } from \"@nivo/scales\";\nimport { jsx as U, jsxs as X, Fragment as j } from \"react/jsx-runtime\";\nimport { useSpring as q, animated as J } from \"@react-spring/web\";\nimport { Mesh as K, useVoronoiMesh as N, renderVoronoiToCanvas as Q, renderVoronoiCellToCanvas as Z } from \"@nivo/voronoi\";\nfunction $() {\n  return $ = Object.assign ? Object.assign.bind() : function (e) {\n    for (var o = 1; o < arguments.length; o++) {\n      var i = arguments[o];\n      for (var n in i) ({}).hasOwnProperty.call(i, n) && (e[n] = i[n]);\n    }\n    return e;\n  }, $.apply(null, arguments);\n}\nfunction _(e, o) {\n  if (null == e) return {};\n  var i = {};\n  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {\n    if (-1 !== o.indexOf(n)) continue;\n    i[n] = e[n];\n  }\n  return i;\n}\nvar ee,\n  oe = {\n    xScale: {\n      type: \"point\"\n    },\n    yScale: {\n      type: \"linear\",\n      min: 0,\n      max: \"auto\"\n    },\n    curve: \"linear\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    lineWidth: 2,\n    layers: [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"],\n    enablePoints: !0,\n    pointSize: 6,\n    pointColor: {\n      from: \"series.color\"\n    },\n    pointBorderWidth: 0,\n    pointBorderColor: {\n      theme: \"background\"\n    },\n    enableArea: !1,\n    areaBaselineValue: 0,\n    areaOpacity: .2,\n    enableGridX: !0,\n    enableGridY: !0,\n    legends: [],\n    isInteractive: !0,\n    tooltip: e(function (e) {\n      var o = e.point;\n      return U(I, {\n        id: X(\"span\", {\n          children: [\"x: \", U(\"strong\", {\n            children: o.data.xFormatted\n          }), \", y:\", \" \", U(\"strong\", {\n            children: o.data.yFormatted\n          })]\n        }),\n        enableChip: !0,\n        color: o.seriesColor\n      });\n    }),\n    sliceTooltip: e(function (e) {\n      var o = e.slice,\n        i = e.axis,\n        n = z(),\n        t = \"x\" === i ? \"y\" : \"x\";\n      return U(F, {\n        rows: o.points.map(function (e) {\n          return [U(E, {\n            color: e.seriesColor,\n            style: n.tooltip.chip\n          }, \"chip\"), e.seriesId, U(\"span\", {\n            style: n.tooltip.tableCellValue,\n            children: e.data[t + \"Formatted\"]\n          }, \"value\")];\n        })\n      });\n    }),\n    debugMesh: !1,\n    renderWrapper: !0\n  },\n  ie = $({}, oe, {\n    defs: [],\n    fill: [],\n    enablePointLabel: !1,\n    pointLabel: \"data.yFormatted\",\n    areaBlendMode: \"normal\",\n    axisTop: null,\n    axisRight: null,\n    axisBottom: B,\n    axisLeft: B,\n    useMesh: !1,\n    enableSlices: !1,\n    debugSlices: !1,\n    enableCrosshair: !0,\n    crosshairType: \"bottom-left\",\n    enableTouchCrosshair: !1,\n    initialHiddenIds: [],\n    animate: !0,\n    motionConfig: \"gentle\",\n    role: \"img\",\n    isFocusable: !1\n  }),\n  ne = $({}, oe, {\n    pixelRatio: \"undefined\" != typeof window && null != (ee = window.devicePixelRatio) ? ee : 1,\n    axisTop: null,\n    axisRight: null,\n    axisBottom: B,\n    axisLeft: B\n  });\nfunction te(e) {\n  return o(function () {\n    return P().defined(function (e) {\n      return null !== e.x && null !== e.y;\n    }).x(function (e) {\n      return e.x;\n    }).y(function (e) {\n      return e.y;\n    }).curve(u(e));\n  }, [e]);\n}\nfunction re(e) {\n  var i = e.curve,\n    n = e.yScale,\n    t = e.areaBaselineValue;\n  return o(function () {\n    return R().defined(function (e) {\n      return null !== e.x && null !== e.y;\n    }).x(function (e) {\n      return e.x;\n    }).y1(function (e) {\n      return e.y;\n    }).curve(u(i)).y0(n(t));\n  }, [i, n, t]);\n}\nvar ae = function (e) {\n    var i = e.componentId,\n      n = e.enableSlices,\n      t = e.points,\n      r = e.width,\n      a = e.height;\n    return o(function () {\n      if (\"x\" === n) {\n        var e = new Map();\n        return t.forEach(function (o) {\n          null !== o.data.x && null !== o.data.y && (e.has(o.x) ? e.get(o.x).push(o) : e.set(o.x, [o]));\n        }), Array.from(e.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, n) {\n          var t,\n            l,\n            s = e[0],\n            u = e[1],\n            d = n[o - 1],\n            c = n[o + 1];\n          return t = d ? s - (s - d[0]) / 2 : s, l = c ? s - t + (c[0] - s) / 2 : r - t, {\n            id: \"slice:\" + i + \":\" + s,\n            x0: t,\n            x: s,\n            y0: 0,\n            y: 0,\n            width: l,\n            height: a,\n            points: u.reverse()\n          };\n        });\n      }\n      if (\"y\" === n) {\n        var o = new Map();\n        return t.forEach(function (e) {\n          null !== e.data.x && null !== e.data.y && (o.has(e.y) ? o.get(e.y).push(e) : o.set(e.y, [e]));\n        }), Array.from(o.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, i) {\n          var n,\n            t,\n            l = e[0],\n            s = e[1],\n            u = i[o - 1],\n            d = i[o + 1];\n          return n = u ? l - (l - u[0]) / 2 : l, t = d ? l - n + (d[0] - l) / 2 : a - n, {\n            id: l,\n            x0: 0,\n            x: 0,\n            y0: n,\n            y: l,\n            width: r,\n            height: t,\n            points: s.reverse()\n          };\n        });\n      }\n      return [];\n    }, [i, n, a, t, r]);\n  },\n  le = \"line\",\n  se = function (e) {\n    var t = e.data,\n      r = e.xScale,\n      a = void 0 === r ? oe.xScale : r,\n      l = e.xFormat,\n      s = e.yScale,\n      u = void 0 === s ? oe.yScale : s,\n      c = e.yFormat,\n      h = e.width,\n      f = e.height,\n      p = e.colors,\n      v = void 0 === p ? oe.colors : p,\n      b = e.curve,\n      g = void 0 === b ? oe.curve : b,\n      m = e.areaBaselineValue,\n      y = void 0 === m ? oe.areaBaselineValue : m,\n      x = e.pointColor,\n      M = void 0 === x ? oe.pointColor : x,\n      C = e.pointBorderColor,\n      S = void 0 === C ? oe.pointBorderColor : C,\n      B = e.enableSlices,\n      w = void 0 === B ? ie.enableSlices : B,\n      T = e.initialHiddenIds,\n      k = void 0 === T ? ie.initialHiddenIds : T,\n      W = i(O(le))[0],\n      L = d(l),\n      D = d(c),\n      I = A(v, \"id\"),\n      F = z(),\n      E = V(M, F),\n      G = V(S, F),\n      H = i(null != k ? k : []),\n      P = H[0],\n      R = H[1],\n      U = o(function () {\n        return Y(t.filter(function (e) {\n          return -1 === P.indexOf(e.id);\n        }), a, u, h, f);\n      }, [t, P, a, u, h, f]),\n      X = U.xScale,\n      j = U.yScale,\n      q = U.series,\n      J = o(function () {\n        var e = t.map(function (e) {\n            return {\n              id: e.id,\n              label: \"\" + e.id,\n              color: I(e)\n            };\n          }),\n          o = e.map(function (e) {\n            return $({}, q.find(function (o) {\n              return o.id === e.id;\n            }), {\n              color: e.color\n            });\n          }).filter(function (e) {\n            return Boolean(e.id);\n          });\n        return {\n          legendData: e.map(function (e) {\n            return $({}, e, {\n              hidden: !o.find(function (o) {\n                return o.id === e.id;\n              })\n            });\n          }).reverse(),\n          series: o\n        };\n      }, [t, q, I]),\n      K = J.legendData,\n      N = J.series,\n      Q = n(function (e) {\n        R(function (o) {\n          return o.indexOf(e) > -1 ? o.filter(function (o) {\n            return o !== e;\n          }) : [].concat(o, [e]);\n        });\n      }, []),\n      Z = function (e) {\n        var i = e.series,\n          n = e.getPointColor,\n          t = e.getPointBorderColor,\n          r = e.formatX,\n          a = e.formatY;\n        return o(function () {\n          return i.reduce(function (e, o, i) {\n            return [].concat(e, o.data.filter(function (e) {\n              return null !== e.position.x && null !== e.position.y;\n            }).map(function (l, s) {\n              var u = {\n                id: o.id + \".\" + s,\n                indexInSeries: s,\n                absIndex: e.length + s,\n                seriesIndex: i,\n                seriesId: o.id,\n                seriesColor: o.color,\n                x: l.position.x,\n                y: l.position.y,\n                data: $({}, l.data, {\n                  xFormatted: r(l.data.x),\n                  yFormatted: a(l.data.y)\n                })\n              };\n              return u.color = n({\n                series: o,\n                point: u\n              }), u.borderColor = t(u), u;\n            }));\n          }, []);\n        }, [i, n, t, r, a]);\n      }({\n        series: N,\n        getPointColor: E,\n        getPointBorderColor: G,\n        formatX: L,\n        formatY: D\n      }),\n      _ = ae({\n        componentId: W,\n        enableSlices: w,\n        points: Z,\n        width: h,\n        height: f\n      });\n    return {\n      legendData: K,\n      toggleSeries: Q,\n      lineGenerator: te(g),\n      areaGenerator: re({\n        curve: g,\n        yScale: j,\n        areaBaselineValue: y\n      }),\n      getColor: I,\n      series: N,\n      xScale: X,\n      yScale: j,\n      slices: _,\n      points: Z\n    };\n  },\n  ue = function (e) {\n    var o = e.areaBlendMode,\n      i = e.areaOpacity,\n      n = e.color,\n      t = e.fill,\n      r = e.path,\n      a = c(),\n      l = a.animate,\n      s = a.config,\n      u = h(r),\n      d = q({\n        color: n,\n        config: s,\n        immediate: !l\n      });\n    return U(J.path, {\n      d: u,\n      fill: t || d.color,\n      fillOpacity: i,\n      strokeWidth: 0,\n      style: {\n        mixBlendMode: o\n      }\n    });\n  },\n  de = e(function (e) {\n    var o = e.areaGenerator,\n      i = e.areaOpacity,\n      n = e.areaBlendMode,\n      t = e.series.slice(0).reverse();\n    return U(\"g\", {\n      children: t.map(function (e) {\n        return U(ue, $({\n          path: o(e.data.map(function (e) {\n            return e.position;\n          }))\n        }, $({\n          areaOpacity: i,\n          areaBlendMode: n\n        }, e)), \"\" + e.id);\n      })\n    });\n  }),\n  ce = e(function (e) {\n    var i = e.lineGenerator,\n      n = e.points,\n      t = e.color,\n      r = e.thickness,\n      a = o(function () {\n        return i(n);\n      }, [i, n]),\n      l = h(a);\n    return U(J.path, {\n      d: l,\n      fill: \"none\",\n      strokeWidth: r,\n      stroke: t\n    });\n  }),\n  he = e(function (e) {\n    var o = e.series,\n      i = e.lineGenerator,\n      n = e.lineWidth;\n    return U(j, {\n      children: o.slice(0).reverse().map(function (e) {\n        var o = e.id,\n          t = e.data,\n          r = e.color;\n        return U(ce, {\n          points: t.map(function (e) {\n            return e.position;\n          }),\n          lineGenerator: i,\n          color: r,\n          thickness: n\n        }, o);\n      })\n    });\n  }),\n  fe = e(function (e) {\n    var o = e.slice,\n      i = e.slices,\n      r = e.axis,\n      a = e.debug,\n      l = e.tooltip,\n      s = e.isCurrent,\n      u = e.setCurrent,\n      d = e.onMouseEnter,\n      c = e.onMouseMove,\n      h = e.onMouseLeave,\n      f = e.onMouseDown,\n      p = e.onMouseUp,\n      v = e.onClick,\n      b = e.onDoubleClick,\n      g = e.onTouchStart,\n      m = e.onTouchMove,\n      y = e.onTouchEnd,\n      x = G(),\n      M = x.showTooltipFromEvent,\n      C = x.hideTooltip,\n      S = n(function (e) {\n        M(t(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), u(o), null == d || d(o, e);\n      }, [M, l, o, r, u, d]),\n      B = n(function (e) {\n        M(t(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), null == c || c(o, e);\n      }, [M, l, o, r, c]),\n      w = n(function (e) {\n        C(), u(null), null == h || h(o, e);\n      }, [C, u, h, o]),\n      T = n(function (e) {\n        null == f || f(o, e);\n      }, [o, f]),\n      k = n(function (e) {\n        null == p || p(o, e);\n      }, [o, p]),\n      W = n(function (e) {\n        null == v || v(o, e);\n      }, [o, v]),\n      L = n(function (e) {\n        null == b || b(o, e);\n      }, [o, b]),\n      D = n(function (e) {\n        M(t(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), u(o), null == g || g(o, e);\n      }, [r, g, u, M, o, l]),\n      I = n(function (e) {\n        var n = e.touches[0],\n          a = document.elementFromPoint(n.clientX, n.clientY),\n          s = null == a ? void 0 : a.getAttribute(\"data-ref\");\n        if (s) {\n          var d = i.find(function (e) {\n            return e.id === s;\n          });\n          d && (M(t(l, {\n            slice: d,\n            axis: r\n          }), e, \"right\"), u(d));\n        }\n        null == m || m(o, e);\n      }, [r, m, u, M, o, i, l]),\n      F = n(function (e) {\n        C(), u(null), null == y || y(o, e);\n      }, [C, u, y, o]);\n    return U(\"rect\", {\n      x: o.x0,\n      y: o.y0,\n      width: o.width,\n      height: o.height,\n      stroke: \"red\",\n      strokeWidth: a ? 1 : 0,\n      strokeOpacity: .75,\n      fill: \"red\",\n      fillOpacity: s && a ? .35 : 0,\n      onMouseEnter: S,\n      onMouseMove: B,\n      onMouseLeave: w,\n      onMouseDown: T,\n      onMouseUp: k,\n      onClick: W,\n      onDoubleClick: L,\n      onTouchStart: D,\n      onTouchMove: I,\n      onTouchEnd: F,\n      \"data-ref\": o.id\n    });\n  }),\n  pe = e(function (e) {\n    var o = e.slices,\n      i = e.axis,\n      n = e.debug,\n      t = e.tooltip,\n      r = e.current,\n      a = e.setCurrent,\n      l = e.onMouseEnter,\n      s = e.onMouseMove,\n      u = e.onMouseLeave,\n      d = e.onMouseDown,\n      c = e.onMouseUp,\n      h = e.onClick,\n      f = e.onDoubleClick,\n      p = e.onTouchStart,\n      v = e.onTouchMove,\n      b = e.onTouchEnd;\n    return U(j, {\n      children: o.map(function (e) {\n        return U(fe, {\n          slice: e,\n          slices: o,\n          axis: i,\n          debug: n,\n          tooltip: t,\n          setCurrent: a,\n          isCurrent: null !== r && r.id === e.id,\n          onMouseEnter: l,\n          onMouseMove: s,\n          onMouseLeave: u,\n          onMouseDown: d,\n          onMouseUp: c,\n          onClick: h,\n          onDoubleClick: f,\n          onTouchStart: p,\n          onTouchMove: v,\n          onTouchEnd: b\n        }, e.id);\n      })\n    });\n  }),\n  ve = e(function (e) {\n    var o = e.points,\n      i = e.symbol,\n      n = e.size,\n      r = e.borderWidth,\n      a = e.enableLabel,\n      l = e.label,\n      s = e.labelYOffset,\n      u = e.isFocusable,\n      d = e.setCurrentPoint,\n      c = e.tooltip,\n      h = e.margin,\n      v = e.ariaLabel,\n      b = e.ariaLabelledBy,\n      g = e.ariaDescribedBy,\n      m = e.ariaHidden,\n      y = e.ariaDisabled,\n      x = f(l),\n      M = G(),\n      C = M.showTooltipAt,\n      S = M.hideTooltip,\n      B = o.slice(0).sort(function (e, o) {\n        return e.indexInSeries - o.indexInSeries;\n      }).sort(function (e, o) {\n        return o.seriesIndex - e.seriesIndex;\n      }).map(function (e) {\n        return {\n          id: e.id,\n          x: e.x,\n          y: e.y,\n          datum: e.data,\n          fill: e.color,\n          stroke: e.borderColor,\n          label: a ? x(e) : null,\n          ariaLabel: v ? v(e) : void 0,\n          ariaLabelledBy: b ? b(e) : void 0,\n          ariaDescribedBy: g ? g(e) : void 0,\n          ariaHidden: m ? m(e) : void 0,\n          ariaDisabled: y ? y(e) : void 0,\n          onFocus: u ? function () {\n            d(e), C(t(c, {\n              point: e\n            }), [h.left + e.x, h.top + e.y], \"top\");\n          } : void 0,\n          onBlur: u ? function () {\n            d(null), S();\n          } : void 0\n        };\n      });\n    return U(\"g\", {\n      children: B.map(function (e) {\n        return U(p, {\n          x: e.x,\n          y: e.y,\n          datum: e.datum,\n          symbol: i,\n          size: n,\n          color: e.fill,\n          borderWidth: r,\n          borderColor: e.stroke,\n          label: e.label,\n          labelYOffset: s,\n          ariaLabel: e.ariaLabel,\n          ariaLabelledBy: e.ariaLabelledBy,\n          ariaDescribedBy: e.ariaDescribedBy,\n          ariaHidden: e.ariaHidden,\n          ariaDisabled: e.ariaDisabled,\n          isFocusable: u,\n          onFocus: e.onFocus,\n          onBlur: e.onBlur,\n          testId: \"line.point.\" + e.id\n        }, e.id);\n      })\n    });\n  }),\n  be = e(function (e) {\n    var o = e.points,\n      i = e.width,\n      r = e.height,\n      a = e.margin,\n      l = e.setCurrent,\n      s = e.onMouseEnter,\n      u = e.onMouseMove,\n      d = e.onMouseLeave,\n      c = e.onMouseDown,\n      h = e.onMouseUp,\n      f = e.onClick,\n      p = e.onDoubleClick,\n      v = e.onTouchStart,\n      b = e.onTouchMove,\n      g = e.onTouchEnd,\n      m = e.tooltip,\n      y = e.debug,\n      x = e.enableTouchCrosshair,\n      M = G(),\n      C = M.showTooltipAt,\n      S = M.hideTooltip,\n      B = n(function (e, o) {\n        C(t(m, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), null == s || s(e, o);\n      }, [C, m, s, a]),\n      w = n(function (e, o) {\n        C(t(m, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), null == u || u(e, o);\n      }, [C, m, a.left, a.top, u]),\n      T = n(function (e, o) {\n        S(), null == d || d(e, o);\n      }, [S, d]),\n      k = n(function (e, o) {\n        null == c || c(e, o);\n      }, [c]),\n      W = n(function (e, o) {\n        null == h || h(e, o);\n      }, [h]),\n      L = n(function (e, o) {\n        null == f || f(e, o);\n      }, [f]),\n      D = n(function (e, o) {\n        null == p || p(e, o);\n      }, [p]),\n      I = n(function (e, o) {\n        C(t(m, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), null == v || v(e, o);\n      }, [a.left, a.top, v, C, m]),\n      F = n(function (e, o) {\n        C(t(m, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), null == b || b(e, o);\n      }, [a.left, a.top, b, C, m]),\n      E = n(function (e, o) {\n        S(), null == g || g(e, o);\n      }, [g, S]);\n    return U(K, {\n      nodes: o,\n      width: i,\n      height: r,\n      setCurrent: l,\n      onMouseEnter: B,\n      onMouseMove: w,\n      onMouseLeave: T,\n      onMouseDown: k,\n      onMouseUp: W,\n      onClick: L,\n      onDoubleClick: D,\n      onTouchStart: I,\n      onTouchMove: F,\n      onTouchEnd: E,\n      enableTouchCrosshair: x,\n      debug: y\n    });\n  }),\n  ge = [\"isInteractive\", \"animate\", \"motionConfig\", \"theme\", \"renderWrapper\"];\nfunction me(e) {\n  var o = e.data,\n    n = e.xScale,\n    t = void 0 === n ? ie.xScale : n,\n    r = e.xFormat,\n    l = e.yScale,\n    s = void 0 === l ? ie.yScale : l,\n    u = e.yFormat,\n    d = e.curve,\n    c = void 0 === d ? ie.curve : d,\n    h = e.margin,\n    f = e.width,\n    p = e.height,\n    v = e.colors,\n    x = void 0 === v ? ie.colors : v,\n    M = e.lineWidth,\n    C = void 0 === M ? ie.lineWidth : M,\n    S = e.layers,\n    B = void 0 === S ? ie.layers : S,\n    k = e.enableArea,\n    W = void 0 === k ? ie.enableArea : k,\n    D = e.areaBaselineValue,\n    I = void 0 === D ? ie.areaBaselineValue : D,\n    F = e.areaOpacity,\n    E = void 0 === F ? ie.areaOpacity : F,\n    G = e.areaBlendMode,\n    P = void 0 === G ? ie.areaBlendMode : G,\n    R = e.enablePoints,\n    O = void 0 === R ? ie.enablePoints : R,\n    z = e.pointSymbol,\n    A = e.pointSize,\n    V = void 0 === A ? ie.pointSize : A,\n    Y = e.pointColor,\n    X = void 0 === Y ? ie.pointColor : Y,\n    j = e.pointBorderWidth,\n    q = void 0 === j ? ie.pointBorderWidth : j,\n    J = e.pointBorderColor,\n    K = void 0 === J ? ie.pointBorderColor : J,\n    N = e.enablePointLabel,\n    Q = void 0 === N ? ie.enablePointLabel : N,\n    Z = e.pointLabel,\n    _ = void 0 === Z ? ie.pointLabel : Z,\n    ee = e.pointLabelYOffset,\n    oe = e.enableGridX,\n    ne = void 0 === oe ? ie.enableGridX : oe,\n    te = e.gridXValues,\n    re = e.enableGridY,\n    ae = void 0 === re ? ie.enableGridY : re,\n    le = e.gridYValues,\n    ue = e.axisTop,\n    ce = e.axisRight,\n    fe = e.axisBottom,\n    ge = void 0 === fe ? ie.axisBottom : fe,\n    me = e.axisLeft,\n    ye = void 0 === me ? ie.axisLeft : me,\n    xe = e.defs,\n    Me = void 0 === xe ? ie.defs : xe,\n    Ce = e.fill,\n    Se = void 0 === Ce ? ie.fill : Ce,\n    Be = e.markers,\n    we = e.legends,\n    Te = void 0 === we ? ie.legends : we,\n    ke = e.isInteractive,\n    We = void 0 === ke ? ie.isInteractive : ke,\n    Le = e.useMesh,\n    De = void 0 === Le ? ie.useMesh : Le,\n    Ie = e.debugMesh,\n    Fe = void 0 === Ie ? ie.debugMesh : Ie,\n    Ee = e.onMouseEnter,\n    Ge = e.onMouseMove,\n    He = e.onMouseLeave,\n    Pe = e.onMouseDown,\n    Re = e.onMouseUp,\n    Oe = e.onClick,\n    ze = e.onDoubleClick,\n    Ae = e.onTouchStart,\n    Ve = e.onTouchMove,\n    Ye = e.onTouchEnd,\n    Ue = e.tooltip,\n    Xe = void 0 === Ue ? ie.tooltip : Ue,\n    je = e.enableSlices,\n    qe = void 0 === je ? ie.enableSlices : je,\n    Je = e.debugSlices,\n    Ke = void 0 === Je ? ie.debugSlices : Je,\n    Ne = e.sliceTooltip,\n    Qe = void 0 === Ne ? ie.sliceTooltip : Ne,\n    Ze = e.enableCrosshair,\n    $e = void 0 === Ze ? ie.enableCrosshair : Ze,\n    _e = e.crosshairType,\n    eo = void 0 === _e ? ie.crosshairType : _e,\n    oo = e.enableTouchCrosshair,\n    io = void 0 === oo ? ie.enableTouchCrosshair : oo,\n    no = e.role,\n    to = void 0 === no ? ie.role : no,\n    ro = e.ariaLabel,\n    ao = e.ariaLabelledBy,\n    lo = e.ariaDescribedBy,\n    so = e.isFocusable,\n    uo = void 0 === so ? ie.isFocusable : so,\n    co = e.pointAriaLabel,\n    ho = e.pointAriaLabelledBy,\n    fo = e.pointAriaDescribedBy,\n    po = e.pointAriaHidden,\n    vo = e.pointAriaDisabled,\n    bo = e.initialHiddenIds,\n    go = void 0 === bo ? ie.initialHiddenIds : bo,\n    mo = e.forwardedRef,\n    yo = b(f, p, h),\n    xo = yo.margin,\n    Mo = yo.innerWidth,\n    Co = yo.innerHeight,\n    So = yo.outerWidth,\n    Bo = yo.outerHeight,\n    wo = se({\n      data: o,\n      xScale: t,\n      xFormat: r,\n      yScale: s,\n      yFormat: u,\n      width: Mo,\n      height: Co,\n      colors: x,\n      curve: c,\n      areaBaselineValue: I,\n      pointColor: X,\n      pointBorderColor: K,\n      enableSlices: qe,\n      initialHiddenIds: go\n    }),\n    To = wo.legendData,\n    ko = wo.toggleSeries,\n    Wo = wo.lineGenerator,\n    Lo = wo.areaGenerator,\n    Do = wo.series,\n    Io = wo.xScale,\n    Fo = wo.yScale,\n    Eo = wo.slices,\n    Go = wo.points,\n    Ho = i(null),\n    Po = Ho[0],\n    Ro = Ho[1],\n    Oo = i(null),\n    zo = Oo[0],\n    Ao = Oo[1],\n    Vo = {\n      grid: null,\n      markers: null,\n      axes: null,\n      areas: null,\n      crosshair: null,\n      lines: null,\n      points: null,\n      slices: null,\n      mesh: null,\n      legends: null\n    };\n  B.includes(\"grid\") && (ne || ae) && (Vo.grid = U(w, {\n    width: Mo,\n    height: Co,\n    xScale: ne ? Io : null,\n    yScale: ae ? Fo : null,\n    xValues: te,\n    yValues: le\n  }, \"grid\")), B.includes(\"markers\") && Array.isArray(Be) && Be.length > 0 && (Vo.markers = U(g, {\n    markers: Be,\n    width: Mo,\n    height: Co,\n    xScale: Io,\n    yScale: Fo\n  }, \"markers\")), B.includes(\"axes\") && (Vo.axes = U(T, {\n    xScale: Io,\n    yScale: Fo,\n    width: Mo,\n    height: Co,\n    top: ue,\n    right: ce,\n    bottom: ge,\n    left: ye\n  }, \"axes\")), B.includes(\"lines\") && (Vo.lines = U(he, {\n    series: Do,\n    lineGenerator: Wo,\n    lineWidth: C\n  }, \"lines\")), B.includes(\"legends\") && Te.length > 0 && (Vo.legends = U(a, {\n    children: Te.map(function (e, o) {\n      return U(L, $({}, e, {\n        containerWidth: Mo,\n        containerHeight: Co,\n        data: e.data || To,\n        toggleSerie: e.toggleSerie ? ko : void 0\n      }), o);\n    })\n  }, \"legends\"));\n  var Yo = m(Me, Do, Se);\n  W && (Vo.areas = U(de, {\n    areaGenerator: Lo,\n    areaOpacity: E,\n    areaBlendMode: P,\n    series: Do\n  }, \"areas\")), We && !1 !== qe && (Vo.slices = U(pe, {\n    slices: Eo,\n    axis: qe,\n    debug: Ke,\n    tooltip: Qe,\n    current: zo,\n    setCurrent: Ao,\n    onMouseEnter: Ee,\n    onMouseMove: Ge,\n    onMouseLeave: He,\n    onMouseDown: Pe,\n    onMouseUp: Re,\n    onClick: Oe,\n    onDoubleClick: ze,\n    onTouchStart: Ae,\n    onTouchMove: Ve,\n    onTouchEnd: Ye\n  }, \"slices\")), O && (Vo.points = U(ve, {\n    points: Go,\n    symbol: z,\n    size: V,\n    borderWidth: q,\n    enableLabel: Q,\n    label: _,\n    labelYOffset: ee,\n    isFocusable: uo,\n    setCurrentPoint: Ro,\n    tooltip: Xe,\n    margin: xo,\n    ariaLabel: co,\n    ariaLabelledBy: ho,\n    ariaDescribedBy: fo,\n    ariaHidden: po,\n    ariaDisabled: vo\n  }, \"points\")), We && $e && (null !== Po && (Vo.crosshair = U(H, {\n    width: Mo,\n    height: Co,\n    x: Po.x,\n    y: Po.y,\n    type: eo\n  }, \"crosshair\")), null !== zo && qe && (Vo.crosshair = U(H, {\n    width: Mo,\n    height: Co,\n    x: zo.x,\n    y: zo.y,\n    type: qe\n  }, \"crosshair\"))), We && De && !1 === qe && (Vo.mesh = U(be, {\n    points: Go,\n    width: Mo,\n    height: Co,\n    margin: xo,\n    setCurrent: Ro,\n    onMouseEnter: Ee,\n    onMouseMove: Ge,\n    onMouseLeave: He,\n    onMouseDown: Pe,\n    onMouseUp: Re,\n    onClick: Oe,\n    onDoubleClick: ze,\n    onTouchStart: Ae,\n    onTouchMove: Ve,\n    onTouchEnd: Ye,\n    tooltip: Xe,\n    enableTouchCrosshair: io,\n    debug: Fe\n  }, \"mesh\"));\n  var Uo = $({}, e, {\n    innerWidth: Mo,\n    innerHeight: Co,\n    series: Do,\n    slices: Eo,\n    points: Go,\n    xScale: Io,\n    yScale: Fo,\n    lineGenerator: Wo,\n    areaGenerator: Lo,\n    currentPoint: Po,\n    setCurrentPoint: Ro,\n    currentSlice: zo,\n    setCurrentSlice: Ao\n  });\n  return U(y, {\n    defs: Yo,\n    width: So,\n    height: Bo,\n    margin: xo,\n    role: to,\n    ariaLabel: ro,\n    ariaLabelledBy: ao,\n    ariaDescribedBy: lo,\n    isFocusable: uo,\n    ref: mo,\n    children: B.map(function (e, o) {\n      return \"function\" == typeof e ? U(a, {\n        children: e(Uo)\n      }, o) : Vo[e];\n    })\n  });\n}\nvar ye = r(function (e, o) {\n    var i = e.isInteractive,\n      n = void 0 === i ? ie.isInteractive : i,\n      t = e.animate,\n      r = void 0 === t ? ie.animate : t,\n      a = e.motionConfig,\n      l = void 0 === a ? ie.motionConfig : a,\n      s = e.theme,\n      u = e.renderWrapper,\n      d = _(e, ge);\n    return U(v, {\n      animate: r,\n      isInteractive: n,\n      motionConfig: l,\n      renderWrapper: u,\n      theme: s,\n      children: U(me, $({\n        isInteractive: n\n      }, d, {\n        forwardedRef: o\n      }))\n    });\n  }),\n  xe = [\"defaultWidth\", \"defaultHeight\", \"onResize\", \"debounceResize\"],\n  Me = r(function (e, o) {\n    var i = e.defaultWidth,\n      n = e.defaultHeight,\n      t = e.onResize,\n      r = e.debounceResize,\n      a = _(e, xe);\n    return U(x, {\n      defaultWidth: i,\n      defaultHeight: n,\n      onResize: t,\n      debounceResize: r,\n      children: function (e) {\n        var i = e.width,\n          n = e.height;\n        return U(ye, $({\n          width: i,\n          height: n\n        }, a, {\n          ref: o\n        }));\n      }\n    });\n  }),\n  Ce = [\"isInteractive\", \"renderWrapper\", \"theme\"],\n  Se = function (e) {\n    var r = e.width,\n      a = e.height,\n      u = e.margin,\n      d = e.pixelRatio,\n      c = void 0 === d ? ne.pixelRatio : d,\n      h = e.data,\n      f = e.xScale,\n      p = void 0 === f ? ne.xScale : f,\n      v = e.xFormat,\n      g = e.yScale,\n      m = void 0 === g ? ne.yScale : g,\n      y = e.yFormat,\n      x = e.curve,\n      B = void 0 === x ? ne.curve : x,\n      w = e.layers,\n      T = void 0 === w ? ne.layers : w,\n      L = e.colors,\n      I = void 0 === L ? ne.colors : L,\n      F = e.lineWidth,\n      E = void 0 === F ? ne.lineWidth : F,\n      H = e.enableArea,\n      P = void 0 === H ? ne.enableArea : H,\n      R = e.areaBaselineValue,\n      O = void 0 === R ? ne.areaBaselineValue : R,\n      A = e.areaOpacity,\n      V = void 0 === A ? ne.areaOpacity : A,\n      Y = e.enablePoints,\n      X = void 0 === Y ? ne.enablePoints : Y,\n      j = e.pointSize,\n      q = void 0 === j ? ne.pointSize : j,\n      J = e.pointColor,\n      K = void 0 === J ? ne.pointColor : J,\n      _ = e.pointBorderWidth,\n      ee = void 0 === _ ? ne.pointBorderWidth : _,\n      oe = e.pointBorderColor,\n      ie = void 0 === oe ? ne.pointBorderColor : oe,\n      te = e.enableGridX,\n      re = void 0 === te ? ne.enableGridX : te,\n      ae = e.gridXValues,\n      le = e.enableGridY,\n      ue = void 0 === le ? ne.enableGridY : le,\n      de = e.gridYValues,\n      ce = e.axisTop,\n      he = e.axisRight,\n      fe = e.axisBottom,\n      pe = void 0 === fe ? ne.axisBottom : fe,\n      ve = e.axisLeft,\n      be = void 0 === ve ? ne.axisLeft : ve,\n      ge = e.legends,\n      me = void 0 === ge ? ne.legends : ge,\n      ye = e.isInteractive,\n      xe = void 0 === ye ? ne.isInteractive : ye,\n      Me = e.debugMesh,\n      Ce = void 0 === Me ? ne.debugMesh : Me,\n      Se = e.onMouseLeave,\n      Be = e.onMouseDown,\n      we = e.onMouseUp,\n      Te = e.onClick,\n      ke = e.onDoubleClick,\n      We = e.tooltip,\n      Le = void 0 === We ? ne.tooltip : We,\n      De = e.role,\n      Ie = e.forwardedRef,\n      Fe = l(null),\n      Ee = b(r, a, u),\n      Ge = Ee.margin,\n      He = Ee.innerWidth,\n      Pe = Ee.innerHeight,\n      Re = Ee.outerWidth,\n      Oe = Ee.outerHeight,\n      ze = z(),\n      Ae = i(null),\n      Ve = Ae[0],\n      Ye = Ae[1],\n      Ue = se({\n        data: h,\n        xScale: p,\n        xFormat: v,\n        yScale: m,\n        yFormat: y,\n        width: He,\n        height: Pe,\n        colors: I,\n        curve: B,\n        areaBaselineValue: O,\n        pointColor: K,\n        pointBorderColor: ie\n      }),\n      Xe = Ue.lineGenerator,\n      je = Ue.areaGenerator,\n      qe = Ue.series,\n      Je = Ue.xScale,\n      Ke = Ue.yScale,\n      Ne = Ue.points,\n      Qe = o(function () {\n        return {\n          innerWidth: He,\n          innerHeight: Pe,\n          series: qe,\n          points: Ne,\n          xScale: Je,\n          yScale: Ke,\n          lineWidth: E,\n          lineGenerator: Xe,\n          areaGenerator: je,\n          currentPoint: Ve,\n          setCurrentPoint: Ye\n        };\n      }, [He, Pe, qe, Ne, Je, Ke, E, Xe, je, Ve, Ye]),\n      Ze = N({\n        points: Ne,\n        width: He,\n        height: Pe,\n        debug: Ce\n      }),\n      $e = Ze.delaunay,\n      _e = Ze.voronoi;\n    s(function () {\n      if (null !== Fe.current) {\n        Fe.current.width = Re * c, Fe.current.height = Oe * c;\n        var e = Fe.current.getContext(\"2d\");\n        e.scale(c, c), e.fillStyle = ze.background, e.fillRect(0, 0, Re, Oe), e.translate(Ge.left, Ge.top), T.forEach(function (o) {\n          var i;\n          \"function\" == typeof o && o(e, Qe);\n          var n = null != (i = ze.grid.line.strokeWidth) ? i : 0;\n          if (\"grid\" === o && \"string\" != typeof n && n > 0 && (e.lineWidth = n, e.strokeStyle = ze.grid.line.stroke, re && k(e, {\n            width: He,\n            height: Pe,\n            scale: Je,\n            axis: \"x\",\n            values: ae\n          }), ue && k(e, {\n            width: He,\n            height: Pe,\n            scale: Ke,\n            axis: \"y\",\n            values: de\n          })), \"axes\" === o && W(e, {\n            xScale: Je,\n            yScale: Ke,\n            width: He,\n            height: Pe,\n            top: ce,\n            right: he,\n            bottom: pe,\n            left: be,\n            theme: ze\n          }), \"areas\" === o && !0 === P) {\n            e.save(), e.globalAlpha = V, je.context(e);\n            for (var t = qe.length - 1; t >= 0; t--) e.fillStyle = qe[t].color, e.beginPath(), je(qe[t].data.map(function (e) {\n              return e.position;\n            })), e.fill();\n            e.restore();\n          }\n          if (\"lines\" === o && (Xe.context(e), qe.forEach(function (o) {\n            e.strokeStyle = o.color, e.lineWidth = E, e.beginPath(), Xe(o.data.map(function (e) {\n              return e.position;\n            })), e.stroke();\n          })), \"points\" === o && !0 === X && q > 0 && Ne.forEach(function (o) {\n            e.fillStyle = o.color, e.beginPath(), e.arc(o.x, o.y, q / 2, 0, 2 * Math.PI), e.fill(), ee > 0 && (e.strokeStyle = o.borderColor, e.lineWidth = ee, e.stroke());\n          }), \"mesh\" === o && !0 === Ce && void 0 !== _e && (Q(e, _e), Ve && Z(e, _e, Ve.absIndex)), \"legends\" === o) {\n            var r = qe.map(function (e) {\n              return {\n                id: e.id,\n                label: e.id,\n                color: e.color\n              };\n            }).reverse();\n            me.forEach(function (o) {\n              D(e, $({}, o, {\n                data: o.data || r,\n                containerWidth: He,\n                containerHeight: Pe,\n                theme: ze\n              }));\n            });\n          }\n        });\n      }\n    }, [Fe, He, Re, Pe, Oe, Ge.left, Ge.top, c, T, ze, Xe, qe, Je, Ke, re, ae, ue, de, ce, he, pe, be, me, Ne, X, q, ee, Ve, Qe, Ce, P, je, V, E, _e]);\n    var eo = n(function (e) {\n        if (!Fe.current) return null;\n        var o = M(Fe.current, e),\n          i = o[0],\n          n = o[1];\n        if (!C(Ge.left, Ge.top, He, Pe, i, n)) return null;\n        var t = $e.find(i - Ge.left, n - Ge.top);\n        return Ne[t];\n      }, [Fe, Ge, He, Pe, $e, Ne]),\n      oo = G(),\n      io = oo.showTooltipFromEvent,\n      no = oo.hideTooltip,\n      to = n(function (e) {\n        var o = eo(e);\n        Ye(o), o ? io(t(Le, {\n          point: o\n        }), e) : no();\n      }, [eo, Ye, io, no, Le]),\n      ro = n(function (e) {\n        no(), Ye(null), Ve && (null == Se || Se(Ve, e));\n      }, [no, Ye, Se, Ve]),\n      ao = n(function (e) {\n        if (Be) {\n          var o = eo(e);\n          o && Be(o, e);\n        }\n      }, [eo, Be]),\n      lo = n(function (e) {\n        if (we) {\n          var o = eo(e);\n          o && we(o, e);\n        }\n      }, [eo, we]),\n      so = n(function (e) {\n        if (Te) {\n          var o = eo(e);\n          o && Te(o, e);\n        }\n      }, [eo, Te]),\n      uo = n(function (e) {\n        if (ke) {\n          var o = eo(e);\n          o && ke(o, e);\n        }\n      }, [eo, ke]);\n    return U(\"canvas\", {\n      ref: S(Fe, Ie),\n      width: Re * c,\n      height: Oe * c,\n      style: {\n        width: Re,\n        height: Oe,\n        cursor: xe ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: xe ? to : void 0,\n      onMouseMove: xe ? to : void 0,\n      onMouseLeave: xe ? ro : void 0,\n      onMouseDown: xe ? ao : void 0,\n      onMouseUp: xe ? lo : void 0,\n      onClick: xe ? so : void 0,\n      onDoubleClick: xe ? uo : void 0,\n      role: De\n    });\n  },\n  Be = r(function (e, o) {\n    var i = e.isInteractive,\n      n = e.renderWrapper,\n      t = e.theme,\n      r = _(e, Ce);\n    return U(v, {\n      isInteractive: i,\n      renderWrapper: n,\n      theme: t,\n      animate: !1,\n      children: U(Se, $({}, r, {\n        forwardedRef: o\n      }))\n    });\n  }),\n  we = [\"defaultWidth\", \"defaultHeight\", \"onResize\", \"debounceResize\"],\n  Te = r(function (e, o) {\n    var i = e.defaultWidth;\n    e.defaultHeight;\n    var n = e.onResize,\n      t = e.debounceResize,\n      r = _(e, we);\n    return U(x, {\n      defaultWidth: i,\n      defaultHeight: i,\n      onResize: n,\n      debounceResize: t,\n      children: function (e) {\n        var i = e.width,\n          n = e.height;\n        return U(Be, $({\n          width: i,\n          height: n\n        }, r, {\n          ref: o\n        }));\n      }\n    });\n  });\nfunction ke(e) {\n  return void 0 !== e.seriesId;\n}\nfunction We(e) {\n  return void 0 !== e.points;\n}\nexport { le as LINE_UNIQUE_ID_PREFIX, ye as Line, Be as LineCanvas, Me as ResponsiveLine, Te as ResponsiveLineCanvas, ne as canvasDefaultProps, oe as commonDefaultProps, ke as isPoint, We as isSliceData, ie as svgDefaultProps, re as useAreaGenerator, se as useLine, te as useLineGenerator, ae as useSlices };","map":{"version":3,"names":["ee","oe","xScale","type","yScale","min","max","curve","colors","scheme","lineWidth","layers","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","theme","enableArea","areaBaselineValue","areaOpacity","enableGridX","enableGridY","legends","isInteractive","tooltip","e","o","point","U","I","id","X","children","data","xFormatted","yFormatted","enableChip","color","seriesColor","sliceTooltip","slice","i","axis","n","z","t","F","rows","points","map","E","style","chip","seriesId","tableCellValue","debugMesh","renderWrapper","ie","$","defs","fill","enablePointLabel","pointLabel","areaBlendMode","axisTop","axisRight","axisBottom","B","axisLeft","useMesh","enableSlices","debugSlices","enableCrosshair","crosshairType","enableTouchCrosshair","initialHiddenIds","animate","motionConfig","role","isFocusable","ne","pixelRatio","window","devicePixelRatio","te","P","defined","x","y","u","re","R","y1","y0","ae","useSlices","componentId","r","width","a","height","Map","forEach","has","get","push","set","Array","entries","sort","l","s","d","c","x0","reverse","le","se","useLine","xFormat","yFormat","h","f","p","v","b","g","m","M","C","S","w","T","k","W","O","L","D","A","V","G","H","Y","filter","indexOf","j","q","series","J","label","find","Boolean","legendData","hidden","K","N","Q","concat","Z","getPointColor","getPointBorderColor","formatX","formatY","reduce","position","indexInSeries","absIndex","length","seriesIndex","borderColor","_","toggleSeries","lineGenerator","areaGenerator","getColor","slices","ue","AreaPath","path","config","immediate","fillOpacity","strokeWidth","mixBlendMode","de","ce","thickness","stroke","he","fe","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","onTouchEnd","showTooltipFromEvent","hideTooltip","touches","document","elementFromPoint","clientX","clientY","getAttribute","strokeOpacity","pe","current","ve","symbol","size","borderWidth","enableLabel","labelYOffset","setCurrentPoint","margin","ariaLabel","ariaLabelledBy","ariaDescribedBy","ariaHidden","ariaDisabled","showTooltipAt","datum","onFocus","left","top","onBlur","testId","be","nodes","ge","me","pointSymbol","pointLabelYOffset","gridXValues","gridYValues","ye","xe","Me","Ce","Se","Be","markers","we","Te","ke","We","Le","De","Ie","Fe","Ee","Ge","He","Pe","Re","Oe","ze","Ae","Ve","Ye","Ue","Xe","je","qe","Je","Ke","Ne","Qe","Ze","$e","_e","eo","oo","io","no","to","ro","ao","lo","so","uo","co","pointAriaLabel","ho","pointAriaLabelledBy","fo","pointAriaDescribedBy","po","pointAriaHidden","vo","pointAriaDisabled","bo","go","mo","forwardedRef","yo","xo","Mo","innerWidth","Co","innerHeight","So","outerWidth","Bo","outerHeight","wo","To","ko","Wo","Lo","Do","Io","Fo","Eo","Go","Ho","Po","Ro","Oo","zo","Ao","Vo","grid","axes","areas","crosshair","lines","mesh","includes","xValues","yValues","isArray","right","bottom","containerWidth","containerHeight","toggleSerie","Yo","Uo","currentPoint","currentSlice","setCurrentSlice","ref","defaultWidth","defaultHeight","onResize","debounceResize","InnerLineCanvas","delaunay","voronoi","getContext","scale","fillStyle","background","fillRect","translate","line","strokeStyle","values","save","globalAlpha","context","beginPath","restore","arc","Math","PI","cursor","LINE_UNIQUE_ID_PREFIX","Line","LineCanvas","ResponsiveLine","ResponsiveLineCanvas","canvasDefaultProps","commonDefaultProps","isPoint","isSliceData","svgDefaultProps","useAreaGenerator","useLineGenerator"],"sources":["C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\PointTooltip.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\defaults.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\SliceTooltip.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\hooks.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Areas.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\LinesItem.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Lines.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\SlicesItem.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Slices.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Points.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Mesh.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\Line.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\ResponsiveLine.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\LineCanvas.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\ResponsiveLineCanvas.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\line\\src\\types.ts"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { LineSeries, PointTooltipProps } from './types'\n\nexport const NonMemoizedPointTooltip = <Series extends LineSeries>({\n    point,\n}: PointTooltipProps<Series>) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.seriesColor}\n        />\n    )\n}\n\nexport const PointTooltip = memo(NonMemoizedPointTooltip)\n","import { defaultAxisProps } from '@nivo/axes'\nimport {\n    CommonLineProps,\n    LineSvgPropsWithDefaults,\n    LineCanvasPropsWithDefaults,\n    DefaultSeries,\n    LineLayerId,\n} from './types'\nimport { PointTooltip } from './PointTooltip'\nimport { SliceTooltip } from './SliceTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonLineProps<DefaultSeries>,\n    | 'data'\n    | 'xFormat'\n    | 'yFormat'\n    | 'layers'\n    | 'width'\n    | 'height'\n    | 'margin'\n    | 'theme'\n    | 'pointSymbol'\n    | 'gridXValues'\n    | 'gridYValues'\n    | 'onMouseEnter'\n    | 'onMouseMove'\n    | 'onMouseLeave'\n    | 'onMouseDown'\n    | 'onMouseUp'\n    | 'onClick'\n    | 'onDoubleClick'\n    | 'onTouchStart'\n    | 'onTouchMove'\n    | 'onTouchEnd'\n> & {\n    layers: LineLayerId[]\n} = {\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n    curve: 'linear',\n    colors: { scheme: 'nivo' },\n    lineWidth: 2,\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'series.color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    enableGridX: true,\n    enableGridY: true,\n    legends: [],\n    isInteractive: true,\n    tooltip: PointTooltip,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    renderWrapper: true,\n}\n\nexport const svgDefaultProps: Omit<\n    LineSvgPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    defs: [],\n    fill: [],\n    enablePointLabel: false,\n    pointLabel: 'data.yFormatted',\n    areaBlendMode: 'normal',\n    axisTop: null,\n    axisRight: null,\n    axisBottom: defaultAxisProps,\n    axisLeft: defaultAxisProps,\n    useMesh: false,\n    enableSlices: false,\n    debugSlices: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n    enableTouchCrosshair: false,\n    initialHiddenIds: [],\n    animate: true,\n    motionConfig: 'gentle',\n    role: 'img',\n    isFocusable: false,\n}\n\nexport const canvasDefaultProps: Omit<\n    LineCanvasPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? (window.devicePixelRatio ?? 1) : 1,\n    axisTop: null,\n    axisRight: null,\n    axisBottom: defaultAxisProps,\n    axisLeft: defaultAxisProps,\n}\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceTooltipProps } from './types'\n\nexport const NonMemoizedSliceTooltip = <Series extends LineSeries>({\n    slice,\n    axis,\n}: SliceTooltipProps<Series>) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.seriesColor} style={theme.tooltip.chip} />,\n                point.seriesId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport const SliceTooltip = memo(NonMemoizedSliceTooltip)\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport uniqueId from 'lodash/uniqueId.js'\nimport { curveFromProp, useValueFormatter } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport {\n    useOrdinalColorScale,\n    useInheritedColor,\n    OrdinalColorScaleConfig,\n    InheritedColorConfig,\n} from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { commonDefaultProps, svgDefaultProps } from './defaults'\nimport {\n    LineSeries,\n    CommonLineProps,\n    DataProps,\n    InferX,\n    InferY,\n    InferSeriesId,\n    LineSvgProps,\n    LineGenerator,\n    AreaGenerator,\n    AllowedValue,\n    ComputedSeries,\n    Point,\n    SliceData,\n    PointColorContext,\n} from './types'\n\nexport function useLineGenerator(curve: CommonLineProps<LineSeries>['curve']): LineGenerator {\n    return useMemo(() => {\n        return line<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y(d => d.y)\n            .curve(curveFromProp(curve))\n    }, [curve])\n}\n\nexport function useAreaGenerator<Y extends AllowedValue>({\n    curve,\n    yScale,\n    areaBaselineValue,\n}: {\n    curve: CommonLineProps<LineSeries>['curve']\n    yScale: (y: Y) => number\n    areaBaselineValue: Y\n}): AreaGenerator {\n    return useMemo(() => {\n        return area<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nfunction usePoints<Series extends LineSeries>({\n    series,\n    getPointColor,\n    getPointBorderColor,\n    formatX,\n    formatY,\n}: {\n    series: ComputedSeries<Series>[]\n    getPointColor: (context: PointColorContext<Series>) => string\n    getPointBorderColor: (point: Omit<Point<Series>, 'borderColor'>) => string\n    formatX: (x: InferX<Series>) => string\n    formatY: (y: InferY<Series>) => string\n}) {\n    return useMemo(() => {\n        return series.reduce((acc, seriesItem, seriesIndex) => {\n            return [\n                ...acc,\n                ...seriesItem.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, indexInSeries) => {\n                        const point: Omit<Point<Series>, 'color' | 'borderColor'> & {\n                            color?: string\n                            borderColor?: string\n                        } = {\n                            id: `${seriesItem.id}.${indexInSeries}`,\n                            indexInSeries,\n                            absIndex: acc.length + indexInSeries,\n                            seriesIndex,\n                            seriesId: seriesItem.id,\n                            seriesColor: seriesItem.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                            data: {\n                                ...datum.data,\n                                xFormatted: formatX(datum.data.x as InferX<Series>),\n                                yFormatted: formatY(datum.data.y as InferY<Series>),\n                            },\n                        }\n                        point.color = getPointColor({\n                            series: seriesItem,\n                            point: point as Omit<Point<Series>, 'color' | 'borderColor'>,\n                        })\n                        point.borderColor = getPointBorderColor(\n                            point as Omit<Point<Series>, 'borderColor'>\n                        )\n\n                        return point as Point<Series>\n                    }),\n            ]\n        }, [] as Point<Series>[])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = <Series extends LineSeries>({\n    componentId,\n    enableSlices,\n    points,\n    width,\n    height,\n}: {\n    componentId: string\n    enableSlices: Exclude<LineSvgProps<Series>['enableSlices'], undefined>\n    points: Point<Series>[]\n    width: number\n    height: number\n}) => {\n    return useMemo(() => {\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        }\n\n        return []\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = <Series extends LineSeries>({\n    data,\n    xScale: xScaleSpec = commonDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = commonDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    curve = commonDefaultProps.curve,\n    areaBaselineValue = commonDefaultProps.areaBaselineValue as InferY<Series>,\n    pointColor = commonDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderColor = commonDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableSlices = svgDefaultProps.enableSlices as Exclude<\n        LineSvgProps<Series>['enableSlices'],\n        undefined\n    >,\n    initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n}: DataProps<Series> &\n    Pick<\n        CommonLineProps<Series>,\n        | 'xScale'\n        | 'yScale'\n        | 'colors'\n        | 'curve'\n        | 'areaBaselineValue'\n        | 'pointColor'\n        | 'pointBorderColor'\n    > & {\n        xFormat?: CommonLineProps<Series>['xFormat']\n        yFormat?: CommonLineProps<Series>['yFormat']\n    } & Pick<LineSvgProps<Series>, 'enableSlices' | 'initialHiddenIds'> & {\n        width: number\n        height: number\n    }): {\n    legendData: {\n        id: InferSeriesId<Series>\n        label: string\n        color: string\n        hidden: boolean\n    }[]\n    toggleSeries: (id: InferSeriesId<Series>) => void\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    getColor: (series: Series) => string\n    series: ComputedSeries<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    slices: SliceData<Series>[]\n    points: Point<Series>[]\n} => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries<Series, Series['data'][number]>(\n                data.filter(item => hiddenIds.indexOf(item.id as InferSeriesId<Series>) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(seriesItem => ({\n            id: seriesItem.id as InferSeriesId<Series>,\n            label: `${seriesItem.id}`,\n            color: getColor(seriesItem),\n        }))\n\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(seriesItem => seriesItem.id === datum.id)!,\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id)) as unknown as ComputedSeries<Series>[]\n\n        const legendData = dataWithColor\n            .map(item => ({\n                ...item,\n                hidden: !series.find(seriesItem => seriesItem.id === item.id),\n            }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSeries = useCallback((id: InferSeriesId<Series>) => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints<Series>({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices<Series>({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator(curve)\n    const areaGenerator = useAreaGenerator<InferY<Series>>({\n        curve,\n        yScale: yScale as (y: InferY<Series>) => number,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale: xScale as (x: InferX<Series>) => number,\n        yScale: yScale as (y: InferY<Series>) => number,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { CssMixBlendMode, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { LineSeries, ComputedSeries, AreaGenerator } from './types'\n\nconst AreaPath = ({\n    areaBlendMode,\n    areaOpacity,\n    color,\n    fill,\n    path,\n}: {\n    areaBlendMode: CssMixBlendMode\n    areaOpacity: number\n    color: string\n    fill?: string\n    path: string\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst NonMemoizedAreas = <Series extends LineSeries>({\n    areaGenerator,\n    areaOpacity,\n    areaBlendMode,\n    series,\n}: {\n    areaGenerator: AreaGenerator\n    areaOpacity: number\n    areaBlendMode: CssMixBlendMode\n    series: readonly ComputedSeries<Series>[]\n}) => {\n    const reversedSeries = series.slice(0).reverse()\n\n    return (\n        <g>\n            {reversedSeries.map(seriesItem => (\n                <AreaPath\n                    key={`${seriesItem.id}`}\n                    path={areaGenerator(seriesItem.data.map(d => d.position))!}\n                    {...{ areaOpacity, areaBlendMode, ...seriesItem }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Areas = memo(NonMemoizedAreas) as typeof NonMemoizedAreas\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\nimport { LineGenerator } from './types'\n\nexport const NonMemoizedLinesItem = ({\n    lineGenerator,\n    points,\n    color,\n    thickness,\n}: {\n    lineGenerator: LineGenerator\n    points: { x: number; y: number }[]\n    color: string\n    thickness: number\n}) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path!)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport const LinesItem = memo(NonMemoizedLinesItem) as typeof NonMemoizedLinesItem\n","import { memo } from 'react'\nimport { LineSeries, ComputedSeries, LineGenerator } from './types'\nimport { LinesItem } from './LinesItem'\n\nexport const NonMemoizedLines = <Series extends LineSeries>({\n    series,\n    lineGenerator,\n    lineWidth,\n}: {\n    series: readonly ComputedSeries<Series>[]\n    lineGenerator: LineGenerator\n    lineWidth: number\n}) => {\n    return (\n        <>\n            {series\n                .slice(0)\n                .reverse()\n                .map(({ id, data, color }) => (\n                    <LinesItem\n                        key={id}\n                        points={data.map(d => d.position)}\n                        lineGenerator={lineGenerator}\n                        color={color}\n                        thickness={lineWidth}\n                    />\n                ))}\n        </>\n    )\n}\n\nexport const Lines = memo(NonMemoizedLines) as typeof NonMemoizedLines\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlicesItem = <Series extends LineSeries>({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slice: SliceData<Series>\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    isCurrent: boolean\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseDown?.(slice, event)\n        },\n        [slice, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseUp?.(slice, event)\n        },\n        [slice, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onDoubleClick?.(slice, event)\n        },\n        [slice, onDoubleClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart?.(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove?.(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport const SlicesItem = memo(NonMemoizedSlicesItem) as typeof NonMemoizedSlicesItem\n","import { memo } from 'react'\nimport { SlicesItem } from './SlicesItem'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlices = <Series extends LineSeries>({\n    slices,\n    axis,\n    debug,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    current: SliceData<Series> | null\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    return (\n        <>\n            {slices.map(slice => (\n                <SlicesItem<Series>\n                    key={slice.id}\n                    slice={slice}\n                    slices={slices}\n                    axis={axis}\n                    debug={debug}\n                    tooltip={tooltip}\n                    setCurrent={setCurrent}\n                    isCurrent={current !== null && current.id === slice.id}\n                    onMouseEnter={onMouseEnter}\n                    onMouseMove={onMouseMove}\n                    onMouseLeave={onMouseLeave}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onClick={onClick}\n                    onDoubleClick={onDoubleClick}\n                    onTouchStart={onTouchStart}\n                    onTouchMove={onTouchMove}\n                    onTouchEnd={onTouchEnd}\n                />\n            ))}\n        </>\n    )\n}\n\nexport const Slices = memo(NonMemoizedSlices) as typeof NonMemoizedSlices\n","import { createElement, memo } from 'react'\n// @ts-expect-error no types\nimport { getLabelGenerator } from '@nivo/core'\nimport { DotsItem, Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, LineSvgPropsWithDefaults, Point } from './types'\n\nconst NonMemoizedPoints = <Series extends LineSeries>({\n    points,\n    symbol,\n    size,\n    borderWidth,\n    enableLabel,\n    label,\n    labelYOffset,\n    isFocusable,\n    setCurrentPoint,\n    tooltip,\n    margin,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    ariaHidden,\n    ariaDisabled,\n}: {\n    points: readonly Point<Series>[]\n    symbol: LineSvgPropsWithDefaults<Series>['pointSymbol']\n    size: number\n    borderWidth: LineSvgPropsWithDefaults<Series>['pointBorderWidth']\n    enableLabel: LineSvgPropsWithDefaults<Series>['enablePointLabel']\n    label: LineSvgPropsWithDefaults<Series>['pointLabel']\n    labelYOffset: LineSvgPropsWithDefaults<Series>['pointLabelYOffset']\n    isFocusable: LineSvgPropsWithDefaults<Series>['isFocusable']\n    setCurrentPoint: (point: Point<Series> | null) => void\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    margin: Margin\n    ariaLabel: LineSvgPropsWithDefaults<Series>['pointAriaLabel']\n    ariaLabelledBy: LineSvgPropsWithDefaults<Series>['pointAriaLabelledBy']\n    ariaDescribedBy: LineSvgPropsWithDefaults<Series>['pointAriaDescribedBy']\n    ariaHidden: LineSvgPropsWithDefaults<Series>['pointAriaHidden']\n    ariaDisabled: LineSvgPropsWithDefaults<Series>['pointAriaDisabled']\n}) => {\n    const getLabel = getLabelGenerator(label)\n\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    // We sort the points so that the lower series are drawn on top of the higher ones.\n    const mappedPoints = points\n        .slice(0)\n        .sort((a, b) => a.indexInSeries - b.indexInSeries)\n        .sort((a, b) => b.seriesIndex - a.seriesIndex)\n        .map(point => {\n            return {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n                ariaLabel: ariaLabel ? ariaLabel(point) : undefined,\n                ariaLabelledBy: ariaLabelledBy ? ariaLabelledBy(point) : undefined,\n                ariaDescribedBy: ariaDescribedBy ? ariaDescribedBy(point) : undefined,\n                ariaHidden: ariaHidden ? ariaHidden(point) : undefined,\n                ariaDisabled: ariaDisabled ? ariaDisabled(point) : undefined,\n                onFocus: isFocusable\n                    ? () => {\n                          setCurrentPoint(point)\n                          showTooltipAt(\n                              createElement(tooltip, { point }),\n                              [margin.left + point.x, margin.top + point.y],\n                              'top'\n                          )\n                      }\n                    : undefined,\n                onBlur: isFocusable\n                    ? () => {\n                          setCurrentPoint(null)\n                          hideTooltip()\n                      }\n                    : undefined,\n            }\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol as any}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    ariaLabel={point.ariaLabel}\n                    ariaLabelledBy={point.ariaLabelledBy}\n                    ariaDescribedBy={point.ariaDescribedBy}\n                    ariaHidden={point.ariaHidden}\n                    ariaDisabled={point.ariaDisabled}\n                    isFocusable={isFocusable}\n                    onFocus={point.onFocus}\n                    onBlur={point.onBlur}\n                    testId={`line.point.${point.id}`}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Points = memo(NonMemoizedPoints) as typeof NonMemoizedPoints\n","import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\nimport { LineSeries, Point, LineSvgProps, LineSvgPropsWithDefaults } from './types'\n\nconst NonMemoizedMesh = <Series extends LineSeries>({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}: {\n    points: Point<Series>[]\n    width: number\n    height: number\n    margin: Margin\n    setCurrent: (point: Point<Series> | null) => void\n    onMouseEnter?: LineSvgProps<Series>['onMouseEnter']\n    onMouseMove?: LineSvgProps<Series>['onMouseMove']\n    onMouseLeave?: LineSvgProps<Series>['onMouseLeave']\n    onMouseDown?: LineSvgProps<Series>['onMouseDown']\n    onMouseUp?: LineSvgProps<Series>['onMouseUp']\n    onClick?: LineSvgProps<Series>['onClick']\n    onDoubleClick?: LineSvgProps<Series>['onDoubleClick']\n    onTouchStart?: LineSvgProps<Series>['onTouchStart']\n    onTouchMove?: LineSvgProps<Series>['onTouchMove']\n    onTouchEnd?: LineSvgProps<Series>['onTouchEnd']\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    debug: boolean\n    enableTouchCrosshair: LineSvgPropsWithDefaults<Series>['enableTouchCrosshair']\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter?.(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove?.(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            hideTooltip()\n            onMouseLeave?.(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseDown?.(point, event)\n        },\n        [onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseUp?.(point, event)\n        },\n        [onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onClick?.(point, event)\n        },\n        [onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onDoubleClick?.(point, event)\n        },\n        [onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart?.(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove?.(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            hideTooltip()\n            onTouchEnd?.(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh<Point<Series>>\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport const Mesh = memo(NonMemoizedMesh) as typeof NonMemoizedMesh\n","import { Fragment, ReactNode, useState, forwardRef, Ref, ReactElement } from 'react'\nimport {\n    // @ts-expect-error no types\n    bindDefs,\n    useDimensions,\n    SvgWrapper,\n    CartesianMarkers,\n    Container,\n    LineCurveFactoryId,\n    WithChartRef,\n} from '@nivo/core'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair, CrosshairType } from '@nivo/tooltip'\nimport { AnyScale } from '@nivo/scales'\nimport { useLine } from './hooks'\nimport { Areas } from './Areas'\nimport { Lines } from './Lines'\nimport { Slices } from './Slices'\nimport { Points } from './Points'\nimport { Mesh } from './Mesh'\nimport {\n    LineSeries,\n    InferSeriesId,\n    InferY,\n    LineLayerId,\n    LineSvgProps,\n    Point,\n    PointColorContext,\n    SliceData,\n    LineCustomSvgLayerProps,\n    PointTooltipComponent,\n    SliceTooltipComponent,\n    LineSvgPropsWithDefaults,\n} from './types'\nimport { svgDefaultProps } from './defaults'\n\nfunction InnerLine<Series extends LineSeries>(\n    props: LineSvgProps<Series> & { forwardedRef: Ref<SVGSVGElement> }\n) {\n    const {\n        data,\n        xScale: xScaleSpec = svgDefaultProps.xScale,\n        xFormat,\n        yScale: yScaleSpec = svgDefaultProps.yScale,\n        yFormat,\n        curve = svgDefaultProps.curve as LineCurveFactoryId,\n        margin: partialMargin,\n        width,\n        height,\n        colors = svgDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n        lineWidth = svgDefaultProps.lineWidth as number,\n        layers = svgDefaultProps.layers as readonly LineLayerId[],\n        enableArea = svgDefaultProps.enableArea,\n        areaBaselineValue = svgDefaultProps.areaBaselineValue as InferY<Series>,\n        areaOpacity = svgDefaultProps.areaOpacity,\n        areaBlendMode = svgDefaultProps.areaBlendMode,\n        enablePoints = svgDefaultProps.enablePoints,\n        pointSymbol,\n        pointSize = svgDefaultProps.pointSize,\n        pointColor = svgDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n        pointBorderWidth = svgDefaultProps.pointBorderWidth,\n        pointBorderColor = svgDefaultProps.pointBorderColor as InheritedColorConfig<\n            Omit<Point<Series>, 'borderColor'>\n        >,\n        enablePointLabel = svgDefaultProps.enablePointLabel,\n        pointLabel = svgDefaultProps.pointLabel as string,\n        pointLabelYOffset,\n        enableGridX = svgDefaultProps.enableGridX,\n        gridXValues,\n        enableGridY = svgDefaultProps.enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = svgDefaultProps.axisBottom,\n        axisLeft = svgDefaultProps.axisLeft,\n        defs = svgDefaultProps.defs,\n        fill = svgDefaultProps.fill,\n        markers,\n        legends = svgDefaultProps.legends,\n        isInteractive = svgDefaultProps.isInteractive,\n        useMesh = svgDefaultProps.useMesh,\n        debugMesh = svgDefaultProps.debugMesh,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        tooltip = svgDefaultProps.tooltip as PointTooltipComponent<Series>,\n        enableSlices = svgDefaultProps.enableSlices,\n        debugSlices = svgDefaultProps.debugSlices,\n        sliceTooltip = svgDefaultProps.sliceTooltip as SliceTooltipComponent<Series>,\n        enableCrosshair = svgDefaultProps.enableCrosshair,\n        crosshairType = svgDefaultProps.crosshairType as CrosshairType,\n        enableTouchCrosshair = svgDefaultProps.enableTouchCrosshair,\n        role = svgDefaultProps.role,\n        ariaLabel,\n        ariaLabelledBy,\n        ariaDescribedBy,\n        isFocusable = svgDefaultProps.isFocusable,\n        pointAriaLabel,\n        pointAriaLabelledBy,\n        pointAriaDescribedBy,\n        pointAriaHidden,\n        pointAriaDisabled,\n        initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n        forwardedRef,\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n    const [currentSlice, setCurrentSlice] = useState<SliceData<Series> | null>(null)\n\n    const layerById: Record<LineLayerId, ReactNode> = {\n        grid: null,\n        markers: null,\n        axes: null,\n        areas: null,\n        crosshair: null,\n        lines: null,\n        points: null,\n        slices: null,\n        mesh: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid') && (enableGridX || enableGridY)) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as AnyScale) : null}\n                yScale={enableGridY ? (yScale as AnyScale) : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('markers') && Array.isArray(markers) && markers.length > 0) {\n        layerById.markers = (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n            />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as AnyScale}\n                yScale={yScale as AnyScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <Lines<Series>\n                key=\"lines\"\n                series={series}\n                lineGenerator={lineGenerator}\n                lineWidth={lineWidth}\n            />\n        )\n    }\n\n    if (layers.includes('legends') && legends.length > 0) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legend.data || legendData}\n                        toggleSerie={\n                            legend.toggleSerie\n                                ? (toggleSeries as (id: string | number) => void)\n                                : undefined\n                        }\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas<Series>\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                series={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices<Series>\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points<Series>\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                borderWidth={pointBorderWidth}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n                isFocusable={isFocusable}\n                setCurrentPoint={setCurrentPoint}\n                tooltip={tooltip}\n                margin={margin}\n                ariaLabel={pointAriaLabel}\n                ariaLabelledBy={pointAriaLabelledBy}\n                ariaDescribedBy={pointAriaDescribedBy}\n                ariaHidden={pointAriaHidden}\n                ariaDisabled={pointAriaDisabled}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null && enableSlices) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh<Series>\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    const customLayerProps: LineCustomSvgLayerProps<Series> = {\n        ...(props as LineSvgPropsWithDefaults<Series>),\n        innerWidth,\n        innerHeight,\n        series,\n        slices,\n        points,\n        xScale,\n        yScale,\n        lineGenerator,\n        areaGenerator,\n        currentPoint,\n        setCurrentPoint,\n        currentSlice,\n        setCurrentSlice,\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{layer(customLayerProps)}</Fragment>\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Line = forwardRef(\n    <Series extends LineSeries>(\n        {\n            isInteractive = svgDefaultProps.isInteractive,\n            animate = svgDefaultProps.animate,\n            motionConfig = svgDefaultProps.motionConfig,\n            theme,\n            renderWrapper,\n            ...otherProps\n        }: LineSvgProps<Series>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container\n            animate={animate}\n            isInteractive={isInteractive}\n            motionConfig={motionConfig}\n            renderWrapper={renderWrapper}\n            theme={theme}\n        >\n            <InnerLine<Series> isInteractive={isInteractive} {...otherProps} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<LineSvgProps<Series>, SVGSVGElement>\n) => ReactElement\n","import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps, WithChartRef } from '@nivo/core'\nimport { Line } from './Line'\nimport { LineSvgProps, LineSeries } from './types'\n\nexport const ResponsiveLine = forwardRef(\n    <Series extends LineSeries>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: ResponsiveProps<LineSvgProps<Series>>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <Line<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<ResponsiveProps<LineSvgProps<Series>>, SVGSVGElement>\n) => ReactElement\n","import {\n    createElement,\n    useRef,\n    useEffect,\n    useState,\n    useCallback,\n    forwardRef,\n    ForwardedRef,\n    MouseEvent,\n    useMemo,\n    ReactElement,\n    Ref,\n} from 'react'\nimport { useDimensions, getRelativeCursor, isCursorInRect, Container, mergeRefs } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { OrdinalColorScaleConfig, InheritedColorConfig } from '@nivo/colors'\nimport { useLine } from './hooks'\nimport {\n    InferY,\n    LineCanvasProps,\n    LineLayerId,\n    LineSeries,\n    PointTooltipComponent,\n    Point,\n    LineCustomCanvasLayerProps,\n    PointColorContext,\n} from './types'\nimport { canvasDefaultProps } from './defaults'\nimport { AnyScale } from '@nivo/scales'\n\nconst InnerLineCanvas = <Series extends LineSeries>({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n    data,\n    xScale: xScaleSpec = canvasDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = canvasDefaultProps.yScale,\n    yFormat,\n    curve = canvasDefaultProps.curve,\n    layers = canvasDefaultProps.layers as LineLayerId[],\n    colors = canvasDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    lineWidth = canvasDefaultProps.lineWidth,\n    enableArea = canvasDefaultProps.enableArea,\n    areaBaselineValue = canvasDefaultProps.areaBaselineValue as InferY<Series>,\n    areaOpacity = canvasDefaultProps.areaOpacity,\n    enablePoints = canvasDefaultProps.enablePoints,\n    pointSize = canvasDefaultProps.pointSize,\n    pointColor = canvasDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderWidth = canvasDefaultProps.pointBorderWidth,\n    pointBorderColor = canvasDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableGridX = canvasDefaultProps.enableGridX,\n    gridXValues,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n    legends = canvasDefaultProps.legends,\n    isInteractive = canvasDefaultProps.isInteractive,\n    debugMesh = canvasDefaultProps.debugMesh,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip = canvasDefaultProps.tooltip as PointTooltipComponent<Series>,\n    role,\n    forwardedRef,\n}: Omit<LineCanvasProps<Series>, 'renderWrapper' | 'theme'> & {\n    forwardedRef: Ref<HTMLCanvasElement>\n}) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const customLayerProps: LineCustomCanvasLayerProps<Series> = useMemo(\n        () => ({\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        }),\n        [\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        ]\n    )\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer(ctx, customLayerProps)\n            }\n\n            const gridLineWidth = theme.grid.line.strokeWidth ?? 0\n            if (layer === 'grid' && typeof gridLineWidth !== 'string' && gridLineWidth > 0) {\n                ctx.lineWidth = gridLineWidth\n                ctx.strokeStyle = theme.grid.line.stroke as string\n\n                if (enableGridX) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale as AnyScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n                }\n\n                if (enableGridY) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale as AnyScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n                }\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: xScale as AnyScale,\n                    yScale: yScale as AnyScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(seriesItem => {\n                    ctx.strokeStyle = seriesItem.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(seriesItem.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true && voronoi !== undefined) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.absIndex)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        innerWidth,\n        outerWidth,\n        innerHeight,\n        outerHeight,\n        margin.left,\n        margin.top,\n        pixelRatio,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        pointBorderWidth,\n        currentPoint,\n        customLayerProps,\n        debugMesh,\n        enableArea,\n        areaGenerator,\n        areaOpacity,\n        lineWidth,\n        voronoi,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (!canvasEl.current) return null\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay, points]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            hideTooltip()\n            setCurrentPoint(null)\n            if (currentPoint) onMouseLeave?.(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave, currentPoint]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseDown) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseDown(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseUp) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseUp(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onDoubleClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onDoubleClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onDoubleClick]\n    )\n\n    return (\n        <canvas\n            ref={mergeRefs<HTMLCanvasElement>(canvasEl, forwardedRef)}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onMouseDown={isInteractive ? handleMouseDown : undefined}\n            onMouseUp={isInteractive ? handleMouseUp : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            onDoubleClick={isInteractive ? handleDoubleClick : undefined}\n            role={role}\n        />\n    )\n}\n\nexport const LineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        { isInteractive, renderWrapper, theme, ...props }: LineCanvasProps<Series>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <Container {...{ isInteractive, renderWrapper, theme }} animate={false}>\n            <InnerLineCanvas<Series> {...props} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: LineCanvasProps<Series> & {\n        ref?: ForwardedRef<HTMLCanvasElement>\n    }\n) => ReactElement\n","import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps, WithChartRef } from '@nivo/core'\nimport { LineCanvasProps, LineSeries } from './types'\nimport { LineCanvas } from './LineCanvas'\n\nexport const ResponsiveLineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: ResponsiveProps<LineCanvasProps<Series>>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultWidth}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <LineCanvas<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<ResponsiveProps<LineCanvasProps<Series>>, HTMLCanvasElement>\n) => ReactElement\n","import { FunctionComponent, MouseEvent, TouchEvent, AriaAttributes } from 'react'\nimport { Line, Area } from 'd3-shape'\nimport {\n    Dimensions,\n    Box,\n    MotionProps,\n    CssMixBlendMode,\n    ValueFormat,\n    SvgDefsAndFill,\n    CartesianMarkerProps,\n    PropertyAccessor,\n    LineCurveFactoryId,\n    DotsItemSymbolComponent,\n} from '@nivo/core'\nimport { PartialTheme } from '@nivo/theming'\nimport { AxisProps, CanvasAxisProps } from '@nivo/axes'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { ScaleSpec, TicksSpec } from '@nivo/scales'\nimport { LegendProps } from '@nivo/legends'\nimport { CrosshairType } from '@nivo/tooltip'\n\nexport type AllowedSeriesId = string | number\n// `null` is allowed in the data to indicate a missing value.\nexport type AllowedValue = string | number | Date | null\nexport type LineSeries = {\n    id: AllowedSeriesId\n    data: readonly { x: AllowedValue; y: AllowedValue }[]\n}\n\nexport type InferSeriesId<T> = T extends { id: infer Id } ? Id : never\n\nexport type InferX<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { x: infer X }\n        ? X\n        : never\n    : never\nexport type InferY<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { y: infer Y }\n        ? Y\n        : never\n    : never\n\nexport type DefaultSeries = {\n    id: string\n    data: readonly {\n        x: string | null\n        y: number | null\n    }[]\n}\n\nexport interface ComputedDatum<Series extends LineSeries> {\n    data: Series['data'][number]\n    position: {\n        x: number\n        y: number\n    }\n}\n\nexport type ComputedSeries<Series extends LineSeries> = Omit<Series, 'data' | 'id'> & {\n    id: InferSeriesId<Series>\n    data: readonly ComputedDatum<Series>[]\n    color: string\n}\n\nexport interface Point<Series extends LineSeries> {\n    id: string\n    indexInSeries: number\n    absIndex: number\n    seriesIndex: number\n    seriesId: InferSeriesId<Series>\n    seriesColor: string\n    x: number\n    y: number\n    color: string\n    borderColor: string\n    data: Series['data'][number] & {\n        xFormatted: string\n        yFormatted: string\n    }\n}\n\nexport type PointColorContext<Series extends LineSeries> = {\n    series: ComputedSeries<Series>\n    point: Omit<Point<Series>, 'color' | 'borderColor'>\n}\n\nexport interface SliceData<Series extends LineSeries> {\n    id: string\n    x0: number\n    x: number\n    y0: number\n    y: number\n    width: number\n    height: number\n    points: readonly Point<Series>[]\n}\n\nexport type PointOrSliceData<Series extends LineSeries> = Point<Series> | SliceData<Series>\nexport function isPoint<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is Point<Series> {\n    return (data as Point<Series>).seriesId !== undefined\n}\nexport function isSliceData<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is SliceData<Series> {\n    return (data as SliceData<Series>).points !== undefined\n}\n\nexport interface DataProps<Series extends LineSeries> {\n    data: readonly Series[]\n}\n\nexport type LineGenerator = Line<{ x: number; y: number }>\nexport type AreaGenerator = Area<{ x: number; y: number }>\n\nexport interface PointTooltipProps<Series extends LineSeries> {\n    point: Point<Series>\n}\nexport type PointTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    PointTooltipProps<Series>\n>\n\nexport interface SliceTooltipProps<Series extends LineSeries> {\n    axis: 'x' | 'y'\n    slice: SliceData<Series>\n}\nexport type SliceTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    SliceTooltipProps<Series>\n>\n\nexport type PointOrSliceMouseHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: MouseEvent\n) => void\nexport type PointOrSliceTouchHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: TouchEvent\n) => void\n\nexport type LineLayerId =\n    | 'grid'\n    | 'markers'\n    | 'axes'\n    | 'areas'\n    | 'crosshair'\n    | 'lines'\n    | 'slices'\n    | 'points'\n    | 'mesh'\n    | 'legends'\n\nexport interface CommonCustomLayerProps<Series extends LineSeries> {\n    innerWidth: number\n    innerHeight: number\n    series: readonly ComputedSeries<Series>[]\n    points: readonly Point<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    currentPoint: Point<Series> | null\n    setCurrentPoint: (point: Point<Series> | null) => void\n}\n\nexport type LineCustomSvgLayerProps<Series extends LineSeries> = Omit<\n    LineSvgPropsWithDefaults<Series>,\n    'xScale' | 'yScale'\n> &\n    CommonCustomLayerProps<Series> & {\n        slices: readonly SliceData<Series>[]\n        currentSlice: SliceData<Series> | null\n        setCurrentSlice: (slice: SliceData<Series> | null) => void\n    }\nexport type LineCustomSvgLayer<Series extends LineSeries> = FunctionComponent<\n    LineCustomSvgLayerProps<Series>\n>\nexport type LineSvgLayer<Series extends LineSeries> = LineLayerId | LineCustomSvgLayer<Series>\n\nexport type LineCustomCanvasLayerProps<Series extends LineSeries> = CommonCustomLayerProps<Series>\nexport type LineCustomCanvasLayer<Series extends LineSeries> = (\n    context: CanvasRenderingContext2D,\n    props: LineCustomCanvasLayerProps<Series>\n) => void\nexport type LineCanvasLayer<Series extends LineSeries> = LineLayerId | LineCustomCanvasLayer<Series>\n\nexport type CommonLineProps<Series extends LineSeries> = {\n    xScale: ScaleSpec\n    xFormat?: ValueFormat<InferX<Series>>\n    yScale: ScaleSpec\n    yFormat?: ValueFormat<InferY<Series>>\n    margin: Box\n    curve: LineCurveFactoryId\n    theme: PartialTheme\n    colors: OrdinalColorScaleConfig<Series>\n    lineWidth: number\n    enablePoints: boolean\n    pointSymbol?: DotsItemSymbolComponent<Point<Series>>\n    pointSize: number\n    pointColor: InheritedColorConfig<PointColorContext<Series>>\n    pointBorderWidth: number\n    pointBorderColor: InheritedColorConfig<Omit<Point<Series>, 'borderColor'>>\n    enableArea: boolean\n    areaBaselineValue: InferY<Series>\n    areaOpacity: number\n    enableGridX: boolean\n    gridXValues?: TicksSpec<InferX<Series>>\n    enableGridY: boolean\n    gridYValues?: TicksSpec<InferY<Series>>\n    legends: readonly LegendProps[]\n    isInteractive: boolean\n    debugMesh: boolean\n    onMouseEnter?: PointOrSliceMouseHandler<Series>\n    onMouseMove?: PointOrSliceMouseHandler<Series>\n    onMouseLeave?: PointOrSliceMouseHandler<Series>\n    onMouseDown?: PointOrSliceMouseHandler<Series>\n    onMouseUp?: PointOrSliceMouseHandler<Series>\n    onClick?: PointOrSliceMouseHandler<Series>\n    onDoubleClick?: PointOrSliceMouseHandler<Series>\n    onTouchStart?: PointOrSliceTouchHandler<Series>\n    onTouchMove?: PointOrSliceTouchHandler<Series>\n    onTouchEnd?: PointOrSliceTouchHandler<Series>\n    tooltip: PointTooltipComponent<Series>\n    sliceTooltip: SliceTooltipComponent<Series>\n    renderWrapper: boolean\n    role?: string\n}\n\nexport interface LineSvgExtraProps<Series extends LineSeries> {\n    layers: readonly LineSvgLayer<Series>[]\n    enablePointLabel: boolean\n    pointLabel: PropertyAccessor<Point<Series>, string>\n    pointLabelYOffset?: number\n    areaBlendMode: CssMixBlendMode\n    axisTop?: AxisProps | null\n    axisRight?: AxisProps | null\n    axisBottom?: AxisProps | null\n    axisLeft?: AxisProps | null\n    useMesh: boolean\n    enableSlices: 'x' | 'y' | false\n    debugSlices: boolean\n    enableCrosshair: boolean\n    crosshairType: CrosshairType\n    enableTouchCrosshair: boolean\n    markers?: readonly CartesianMarkerProps[]\n    initialHiddenIds: readonly InferSeriesId<Series>[]\n    animate: boolean\n    motionConfig: MotionProps['motionConfig']\n    ariaLabel?: AriaAttributes['aria-label']\n    ariaLabelledBy?: AriaAttributes['aria-labelledby']\n    ariaDescribedBy?: AriaAttributes['aria-describedby']\n    isFocusable: boolean\n    pointAriaLabel?: (point: Point<Series>) => AriaAttributes['aria-label']\n    pointAriaLabelledBy?: (point: Point<Series>) => AriaAttributes['aria-labelledby']\n    pointAriaDescribedBy?: (point: Point<Series>) => AriaAttributes['aria-describedby']\n    pointAriaHidden?: (point: Point<Series>) => AriaAttributes['aria-hidden']\n    pointAriaDisabled?: (point: Point<Series>) => AriaAttributes['aria-disabled']\n}\nexport type LineSvgProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineSvgExtraProps<Series>> &\n    SvgDefsAndFill<any>\nexport type LineSvgPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineSvgExtraProps<Series> &\n    SvgDefsAndFill<any>\n\nexport interface LineCanvasExtraProps<Series extends LineSeries> {\n    layers: readonly LineCanvasLayer<Series>[]\n    pixelRatio: number\n    axisTop?: CanvasAxisProps | null\n    axisRight?: CanvasAxisProps | null\n    axisBottom?: CanvasAxisProps | null\n    axisLeft?: CanvasAxisProps | null\n}\nexport type LineCanvasProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineCanvasExtraProps<Series>>\nexport type LineCanvasPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineCanvasExtraProps<Series>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}