{"ast":null,"code":"import { useMemo as n, useState as o, useRef as e, useEffect as i, useCallback as t, forwardRef as l, Fragment as r, createElement as u } from \"react\";\nimport { defaultMargin as a, getRelativeCursor as d, getDistance as s, Container as h, useDimensions as c, SvgWrapper as v, ResponsiveWrapper as f } from \"@nivo/core\";\nimport { scaleLinear as p } from \"d3-scale\";\nimport { Delaunay as g } from \"d3-delaunay\";\nimport { useTooltip as M } from \"@nivo/tooltip\";\nimport { jsx as m, jsxs as b, Fragment as k } from \"react/jsx-runtime\";\nfunction C() {\n  return C = Object.assign ? Object.assign.bind() : function (n) {\n    for (var o = 1; o < arguments.length; o++) {\n      var e = arguments[o];\n      for (var i in e) ({}).hasOwnProperty.call(e, i) && (n[i] = e[i]);\n    }\n    return n;\n  }, C.apply(null, arguments);\n}\nfunction y(n, o) {\n  if (null == n) return {};\n  var e = {};\n  for (var i in n) if ({}.hasOwnProperty.call(n, i)) {\n    if (-1 !== o.indexOf(i)) continue;\n    e[i] = n[i];\n  }\n  return e;\n}\nvar w = {\n    xDomain: [0, 1],\n    yDomain: [0, 1],\n    layers: [\"links\", \"cells\", \"points\", \"bounds\"],\n    enableLinks: !1,\n    linkLineWidth: 1,\n    linkLineColor: \"#bbbbbb\",\n    enableCells: !0,\n    cellLineWidth: 2,\n    cellLineColor: \"#000000\",\n    enablePoints: !0,\n    pointSize: 4,\n    pointColor: \"#666666\",\n    role: \"img\"\n  },\n  D = function (n) {\n    return [n.x, n.y];\n  },\n  L = a,\n  T = \"cursor\",\n  P = \"top\",\n  R = function (n) {\n    var o = n.points,\n      e = n.getNodePosition,\n      i = void 0 === e ? D : e,\n      t = n.margin,\n      l = void 0 === t ? L : t;\n    return o.map(function (n) {\n      var o = i(n),\n        e = o[0],\n        t = o[1];\n      return [e + l.left, t + l.top];\n    });\n  },\n  W = function (n) {\n    var o = n.points,\n      e = n.width,\n      i = n.height,\n      t = n.margin,\n      l = void 0 === t ? L : t,\n      r = n.debug,\n      u = g.from(o),\n      a = r ? u.voronoi([0, 0, l.left + e + l.right, l.top + i + l.bottom]) : void 0;\n    return {\n      points: o,\n      delaunay: u,\n      voronoi: a\n    };\n  },\n  E = function (o) {\n    var e = o.points,\n      i = o.getNodePosition,\n      t = void 0 === i ? D : i,\n      l = o.width,\n      r = o.height,\n      u = o.margin,\n      a = void 0 === u ? L : u,\n      d = o.debug;\n    return n(function () {\n      return W({\n        points: R({\n          points: e,\n          margin: a,\n          getNodePosition: t\n        }),\n        width: l,\n        height: r,\n        margin: a,\n        debug: d\n      });\n    }, [t, e, l, r, a, d]);\n  },\n  x = function (o) {\n    var e = o.data,\n      i = o.width,\n      t = o.height,\n      l = o.xDomain,\n      r = o.yDomain,\n      u = n(function () {\n        return p().domain(l).range([0, i]);\n      }, [l, i]),\n      a = n(function () {\n        return p().domain(r).range([0, t]);\n      }, [r, t]),\n      d = n(function () {\n        return e.map(function (n) {\n          return {\n            x: u(n.x),\n            y: a(n.y),\n            data: n\n          };\n        });\n      }, [e, u, a]);\n    return n(function () {\n      var n = g.from(d.map(function (n) {\n          return [n.x, n.y];\n        })),\n        o = n.voronoi([0, 0, i, t]);\n      return {\n        points: d,\n        delaunay: n,\n        voronoi: o\n      };\n    }, [d, i, t]);\n  },\n  S = function (o) {\n    var e = o.points,\n      i = o.delaunay,\n      t = o.voronoi;\n    return n(function () {\n      return {\n        points: e,\n        delaunay: i,\n        voronoi: t\n      };\n    }, [e, i, t]);\n  },\n  U = function (l) {\n    var r = l.elementRef,\n      u = l.nodes,\n      a = l.getNodePosition,\n      h = void 0 === a ? D : a,\n      c = l.delaunay,\n      v = l.setCurrent,\n      f = l.margin,\n      p = void 0 === f ? L : f,\n      g = l.detectionRadius,\n      m = void 0 === g ? 1 / 0 : g,\n      b = l.isInteractive,\n      k = void 0 === b || b,\n      C = l.onMouseEnter,\n      y = l.onMouseMove,\n      w = l.onMouseLeave,\n      R = l.onMouseDown,\n      W = l.onMouseUp,\n      E = l.onClick,\n      x = l.onDoubleClick,\n      S = l.onTouchStart,\n      U = l.onTouchMove,\n      z = l.onTouchEnd,\n      A = l.enableTouchCrosshair,\n      N = void 0 !== A && A,\n      H = l.tooltip,\n      O = l.tooltipPosition,\n      I = void 0 === O ? T : O,\n      j = l.tooltipAnchor,\n      F = void 0 === j ? P : j,\n      B = o(null),\n      q = B[0],\n      G = B[1],\n      J = e(null);\n    i(function () {\n      J.current = q;\n    }, [J, q]);\n    var K = t(function (n) {\n        if (!r.current || 0 === u.length) return null;\n        var o = d(r.current, n),\n          e = o[0],\n          i = o[1],\n          t = c.find(e, i),\n          l = void 0 !== t ? u[t] : null;\n        if (l && m !== 1 / 0) {\n          var a = h(l),\n            v = a[0],\n            f = a[1];\n          s(e, i, v + p.left, f + p.top) > m && (t = null, l = null);\n        }\n        return null === t || null === l ? null : [t, l];\n      }, [r, c, u, h, p, m]),\n      Q = M(),\n      V = Q.showTooltipAt,\n      X = Q.showTooltipFromEvent,\n      Y = Q.hideTooltip,\n      Z = n(function () {\n        if (H) return \"cursor\" === I ? function (n, o) {\n          X(H(n), o, F);\n        } : function (n) {\n          var o = h(n),\n            e = o[0],\n            i = o[1];\n          V(H(n), [e + p.left, i + p.top], F);\n        };\n      }, [V, X, H, I, F, h, p]),\n      $ = t(function (n) {\n        var o = K(n);\n        if (G(o), null == v || v(o ? o[1] : null), o) {\n          var e = o[1];\n          null == Z || Z(e, n), null == C || C(o[1], n);\n        }\n      }, [K, G, v, Z, C]),\n      _ = t(function (n) {\n        var o = K(n);\n        if (G(o), o) {\n          var e = o[0],\n            i = o[1];\n          if (null == v || v(i), null == Z || Z(i, n), J.current) {\n            var t = J.current,\n              l = t[0],\n              r = t[1];\n            e !== l ? null == w || w(r, n) : null == y || y(i, n);\n          } else null == C || C(i, n);\n        } else null == v || v(null), null == Y || Y(), J.current && (null == w || w(J.current[1], n));\n      }, [K, G, v, J, C, y, w, Z, Y]),\n      nn = t(function (n) {\n        G(null), null == v || v(null), Y(), w && J.current && w(J.current[1], n);\n      }, [G, v, J, Y, w]),\n      on = t(function (n) {\n        var o = K(n);\n        G(o), o && (null == R || R(o[1], n));\n      }, [K, G, R]),\n      en = t(function (n) {\n        var o = K(n);\n        G(o), o && (null == W || W(o[1], n));\n      }, [K, G, W]),\n      tn = t(function (n) {\n        var o = K(n);\n        G(o), o && (null == E || E(o[1], n));\n      }, [K, G, E]),\n      ln = t(function (n) {\n        var o = K(n);\n        G(o), o && (null == x || x(o[1], n));\n      }, [K, G, x]),\n      rn = t(function (n) {\n        var o = K(n);\n        N && (G(o), null == v || v(o ? o[1] : null)), o && (null == S || S(o[1], n));\n      }, [K, G, v, N, S]),\n      un = t(function (n) {\n        var o = K(n);\n        N && (G(o), null == v || v(o ? o[1] : null)), o && (null == U || U(o[1], n));\n      }, [K, G, v, N, U]),\n      an = t(function (n) {\n        N && (G(null), null == v || v(null)), z && J.current && z(J.current[1], n);\n      }, [N, G, v, z, J]);\n    return {\n      current: q,\n      handleMouseEnter: k ? $ : void 0,\n      handleMouseMove: k ? _ : void 0,\n      handleMouseLeave: k ? nn : void 0,\n      handleMouseDown: k ? on : void 0,\n      handleMouseUp: k ? en : void 0,\n      handleClick: k ? tn : void 0,\n      handleDoubleClick: k ? ln : void 0,\n      handleTouchStart: k ? rn : void 0,\n      handleTouchMove: k ? un : void 0,\n      handleTouchEnd: k ? an : void 0\n    };\n  },\n  z = function (n) {\n    var o = n.elementRef,\n      e = n.nodes,\n      i = n.getNodePosition,\n      t = n.width,\n      l = n.height,\n      r = n.margin,\n      u = void 0 === r ? L : r,\n      a = n.isInteractive,\n      d = void 0 === a || a,\n      s = n.detectionRadius,\n      h = void 0 === s ? 1 / 0 : s,\n      c = n.setCurrent,\n      v = n.onMouseEnter,\n      f = n.onMouseMove,\n      p = n.onMouseLeave,\n      g = n.onMouseDown,\n      M = n.onMouseUp,\n      m = n.onClick,\n      b = n.onDoubleClick,\n      k = n.tooltip,\n      C = n.tooltipPosition,\n      y = void 0 === C ? T : C,\n      w = n.tooltipAnchor,\n      D = void 0 === w ? P : w,\n      R = n.debug,\n      W = E({\n        points: e,\n        getNodePosition: i,\n        width: t,\n        height: l,\n        margin: u,\n        debug: void 0 !== R && R\n      }),\n      x = W.delaunay,\n      S = W.voronoi,\n      z = U({\n        elementRef: o,\n        nodes: e,\n        margin: u,\n        setCurrent: c,\n        delaunay: x,\n        detectionRadius: h,\n        isInteractive: d,\n        onMouseEnter: v,\n        onMouseMove: f,\n        onMouseLeave: p,\n        onMouseDown: g,\n        onMouseUp: M,\n        onClick: m,\n        onDoubleClick: b,\n        tooltip: k,\n        tooltipPosition: y,\n        tooltipAnchor: D\n      }),\n      A = z.handleMouseEnter,\n      N = z.handleMouseMove,\n      H = z.handleMouseLeave,\n      O = z.handleMouseDown,\n      I = z.handleMouseUp,\n      j = z.handleClick,\n      F = z.handleDoubleClick;\n    return {\n      delaunay: x,\n      voronoi: S,\n      current: z.current,\n      handleMouseEnter: A,\n      handleMouseMove: N,\n      handleMouseLeave: H,\n      handleMouseDown: O,\n      handleMouseUp: I,\n      handleClick: j,\n      handleDoubleClick: F\n    };\n  },\n  A = [\"theme\"],\n  N = function (n) {\n    var o = n.data,\n      e = n.width,\n      i = n.height,\n      t = n.margin,\n      l = n.layers,\n      a = void 0 === l ? w.layers : l,\n      d = n.xDomain,\n      s = void 0 === d ? w.xDomain : d,\n      h = n.yDomain,\n      f = void 0 === h ? w.yDomain : h,\n      p = n.enableLinks,\n      g = void 0 === p ? w.enableLinks : p,\n      M = n.linkLineWidth,\n      b = void 0 === M ? w.linkLineWidth : M,\n      k = n.linkLineColor,\n      C = void 0 === k ? w.linkLineColor : k,\n      y = n.enableCells,\n      D = void 0 === y ? w.enableCells : y,\n      L = n.cellLineWidth,\n      T = void 0 === L ? w.cellLineWidth : L,\n      P = n.cellLineColor,\n      R = void 0 === P ? w.cellLineColor : P,\n      W = n.enablePoints,\n      E = void 0 === W ? w.enableCells : W,\n      U = n.pointSize,\n      z = void 0 === U ? w.pointSize : U,\n      A = n.pointColor,\n      N = void 0 === A ? w.pointColor : A,\n      H = n.role,\n      O = void 0 === H ? w.role : H,\n      I = n.forwardedRef,\n      j = c(e, i, t),\n      F = j.outerWidth,\n      B = j.outerHeight,\n      q = j.margin,\n      G = j.innerWidth,\n      J = j.innerHeight,\n      K = x({\n        data: o,\n        width: G,\n        height: J,\n        xDomain: s,\n        yDomain: f\n      }),\n      Q = K.points,\n      V = K.delaunay,\n      X = K.voronoi,\n      Y = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null\n      };\n    g && a.includes(\"links\") && (Y.links = m(\"path\", {\n      stroke: C,\n      strokeWidth: b,\n      fill: \"none\",\n      d: V.render()\n    }, \"links\")), D && a.includes(\"cells\") && (Y.cells = m(\"path\", {\n      d: X.render(),\n      fill: \"none\",\n      stroke: R,\n      strokeWidth: T\n    }, \"cells\")), E && a.includes(\"points\") && (Y.points = m(\"path\", {\n      stroke: \"none\",\n      fill: N,\n      d: V.renderPoints(void 0, z / 2)\n    }, \"points\")), a.includes(\"bounds\") && (Y.bounds = m(\"path\", {\n      fill: \"none\",\n      stroke: R,\n      strokeWidth: T,\n      d: X.renderBounds()\n    }, \"bounds\"));\n    var Z = S({\n      points: Q,\n      delaunay: V,\n      voronoi: X\n    });\n    return m(v, {\n      width: F,\n      height: B,\n      margin: q,\n      role: O,\n      ref: I,\n      children: a.map(function (n, o) {\n        return void 0 !== Y[n] ? Y[n] : \"function\" == typeof n ? m(r, {\n          children: u(n, Z)\n        }, o) : null;\n      })\n    });\n  },\n  H = l(function (n, o) {\n    var e = n.theme,\n      i = y(n, A);\n    return m(h, {\n      isInteractive: !1,\n      animate: !1,\n      theme: e,\n      children: m(N, C({}, i, {\n        forwardedRef: o\n      }))\n    });\n  }),\n  O = [\"defaultWidth\", \"defaultHeight\", \"onResize\", \"debounceResize\"],\n  I = l(function (n, o) {\n    var e = n.defaultWidth,\n      i = n.defaultHeight,\n      t = n.onResize,\n      l = n.debounceResize,\n      r = y(n, O);\n    return m(f, {\n      defaultWidth: e,\n      defaultHeight: i,\n      onResize: t,\n      debounceResize: l,\n      children: function (n) {\n        var e = n.width,\n          i = n.height;\n        return m(H, C({}, r, {\n          width: e,\n          height: i,\n          ref: o\n        }));\n      }\n    });\n  }),\n  j = function (o) {\n    var i = o.nodes,\n      t = o.width,\n      l = o.height,\n      r = o.margin,\n      u = void 0 === r ? L : r,\n      a = o.getNodePosition,\n      d = o.setCurrent,\n      s = o.onMouseEnter,\n      h = o.onMouseMove,\n      c = o.onMouseLeave,\n      v = o.onMouseDown,\n      f = o.onMouseUp,\n      p = o.onClick,\n      g = o.onDoubleClick,\n      M = o.onTouchStart,\n      C = o.onTouchMove,\n      y = o.onTouchEnd,\n      w = o.enableTouchCrosshair,\n      D = void 0 !== w && w,\n      R = o.detectionRadius,\n      W = void 0 === R ? 1 / 0 : R,\n      x = o.tooltip,\n      S = o.tooltipPosition,\n      z = void 0 === S ? T : S,\n      A = o.tooltipAnchor,\n      N = void 0 === A ? P : A,\n      H = o.debug,\n      O = e(null),\n      I = E({\n        points: i,\n        getNodePosition: a,\n        width: t,\n        height: l,\n        margin: u,\n        debug: H\n      }),\n      j = I.delaunay,\n      F = I.voronoi,\n      B = U({\n        elementRef: O,\n        nodes: i,\n        delaunay: j,\n        margin: u,\n        detectionRadius: W,\n        setCurrent: d,\n        onMouseEnter: s,\n        onMouseMove: h,\n        onMouseLeave: c,\n        onMouseDown: v,\n        onMouseUp: f,\n        onClick: p,\n        onDoubleClick: g,\n        onTouchStart: M,\n        onTouchMove: C,\n        onTouchEnd: y,\n        enableTouchCrosshair: D,\n        tooltip: x,\n        tooltipPosition: z,\n        tooltipAnchor: N\n      }),\n      q = B.current,\n      G = B.handleMouseEnter,\n      J = B.handleMouseMove,\n      K = B.handleMouseLeave,\n      Q = B.handleMouseDown,\n      V = B.handleMouseUp,\n      X = B.handleClick,\n      Y = B.handleDoubleClick,\n      Z = B.handleTouchStart,\n      $ = B.handleTouchMove,\n      _ = B.handleTouchEnd,\n      nn = n(function () {\n        if (H && F) return F.render();\n      }, [H, F]);\n    return b(\"g\", {\n      ref: O,\n      transform: \"translate(\" + -u.left + \",\" + -u.top + \")\",\n      children: [H && F && b(k, {\n        children: [m(\"path\", {\n          d: nn,\n          stroke: \"red\",\n          strokeWidth: 1,\n          opacity: .75\n        }), W < 1 / 0 && m(\"path\", {\n          stroke: \"red\",\n          strokeWidth: .35,\n          fill: \"none\",\n          d: j.renderPoints(void 0, W)\n        }), q && m(\"path\", {\n          fill: \"pink\",\n          opacity: .35,\n          d: F.renderCell(q[0])\n        })]\n      }), m(\"rect\", {\n        \"data-ref\": \"mesh-interceptor\",\n        width: u.left + t + u.right,\n        height: u.top + l + u.bottom,\n        fill: \"red\",\n        opacity: 0,\n        style: {\n          cursor: \"auto\"\n        },\n        onMouseEnter: G,\n        onMouseMove: J,\n        onMouseLeave: K,\n        onMouseDown: Q,\n        onMouseUp: V,\n        onTouchStart: Z,\n        onTouchMove: $,\n        onTouchEnd: _,\n        onClick: X,\n        onDoubleClick: Y\n      })]\n    });\n  },\n  F = function (n, o) {\n    n.save(), n.globalAlpha = .75, n.beginPath(), o.render(n), n.strokeStyle = \"red\", n.lineWidth = 1, n.stroke(), n.restore();\n  },\n  B = function (n, o, e) {\n    n.save(), n.globalAlpha = .15, n.beginPath(), o.renderPoints(n, e), n.strokeStyle = \"red\", n.lineWidth = 1, n.stroke(), n.restore();\n  },\n  q = function (n, o, e) {\n    n.save(), n.globalAlpha = .35, n.beginPath(), o.renderCell(e, n), n.fillStyle = \"pink\", n.fill(), n.restore();\n  },\n  G = function (n, o) {\n    var e = o.delaunay,\n      i = o.voronoi,\n      t = o.detectionRadius,\n      l = o.index;\n    F(n, i), t < 1 / 0 && B(n, e, t), null !== l && q(n, i, l);\n  };\nexport { j as Mesh, I as ResponsiveVoronoi, H as Voronoi, W as computeMesh, R as computeMeshPoints, w as defaultVoronoiProps, G as renderDebugToCanvas, B as renderDelaunayPointsToCanvas, q as renderVoronoiCellToCanvas, F as renderVoronoiToCanvas, z as useMesh, U as useMeshEvents, x as useVoronoi, S as useVoronoiLayerContext, E as useVoronoiMesh };","map":{"version":3,"names":["w","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","D","defaultNodePositionAccessor","n","x","y","L","a","T","P","R","computeMeshPoints","o","points","e","getNodePosition","i","t","margin","l","map","left","top","W","computeMesh","width","height","r","debug","u","g","from","voronoi","right","bottom","delaunay","E","useVoronoiMesh","d","useVoronoi","data","p","domain","range","S","useVoronoiLayerContext","U","useMeshEvents","elementRef","nodes","h","c","v","setCurrent","f","detectionRadius","m","b","isInteractive","k","C","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","z","onTouchEnd","A","enableTouchCrosshair","N","H","tooltip","O","tooltipPosition","I","j","tooltipAnchor","F","B","q","G","J","current","K","length","find","s","Q","M","V","showTooltipAt","X","showTooltipFromEvent","Y","hideTooltip","Z","$","_","nn","on","en","tn","ln","rn","un","an","handleMouseEnter","handleMouseMove","handleMouseLeave","handleMouseDown","handleMouseUp","handleClick","handleDoubleClick","handleTouchStart","handleTouchMove","handleTouchEnd","useMesh","InnerVoronoi","forwardedRef","outerWidth","outerHeight","innerWidth","innerHeight","links","cells","bounds","includes","stroke","strokeWidth","fill","render","renderPoints","renderBounds","ref","children","theme","animate","defaultWidth","defaultHeight","onResize","debounceResize","Mesh","transform","opacity","renderCell","style","cursor","renderVoronoiToCanvas","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderDelaunayPointsToCanvas","renderVoronoiCellToCanvas","fillStyle","renderDebugToCanvas","index","ResponsiveVoronoi","Voronoi","defaultVoronoiProps"],"sources":["C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\props.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\defaults.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\computeMesh.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\hooks.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\Voronoi.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\ResponsiveVoronoi.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\Mesh.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\voronoi\\src\\meshCanvas.ts"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Margin, defaultMargin as coreDefaultMargin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\n\nexport const defaultNodePositionAccessor = (node: {\n    x: number\n    y: number\n}): [x: number, y: number] => [node.x, node.y]\n\nexport const defaultMargin: Margin = coreDefaultMargin\n\nexport const defaultTooltipPosition: TooltipPosition = 'cursor'\nexport const defaultTooltipAnchor: TooltipAnchor = 'top'\n","import { Delaunay } from 'd3-delaunay'\nimport { Margin } from '@nivo/core'\nimport { NodePositionAccessor } from './types'\nimport { defaultNodePositionAccessor, defaultMargin } from './defaults'\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    margin = defaultMargin,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    margin?: Margin\n}): [number, number][] => {\n    return points.map(node => {\n        const [x, y] = getNodePosition(node)\n\n        return [x + margin.left, y + margin.top]\n    })\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly [number, number][]\n    width: number\n    height: number\n    margin?: Margin\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug\n        ? delaunay.voronoi([\n              0,\n              0,\n              margin.left + width + margin.right,\n              margin.top + height + margin.bottom,\n          ])\n        : undefined\n\n    return { points, delaunay, voronoi }\n}\n","import {\n    MouseEvent,\n    MutableRefObject,\n    TouchEvent,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n} from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { getDistance, getRelativeCursor, Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition, useTooltip } from '@nivo/tooltip'\nimport { computeMeshPoints, computeMesh } from './computeMesh'\nimport {\n    VoronoiCommonProps,\n    VoronoiDatum,\n    VoronoiCustomLayerProps,\n    NodeMouseHandler,\n    // DatumTouchHandler,\n    NodePositionAccessor,\n    NodeTouchHandler,\n} from './types'\nimport {\n    defaultMargin,\n    defaultNodePositionAccessor,\n    defaultTooltipPosition,\n    defaultTooltipAnchor,\n} from './defaults'\n\nexport const useVoronoiMesh = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    // Margins are added to the chart's dimensions, so that mouse detection\n    // also works inside the margins, omit if that's not what you want.\n    // When including the margins, we recommend to set a `detectionRadius` as well.\n    margin?: Margin\n    width: number\n    height: number\n    debug?: boolean\n}) =>\n    useMemo(\n        () =>\n            computeMesh({\n                points: computeMeshPoints<Node>({ points, margin, getNodePosition }),\n                width,\n                height,\n                margin,\n                debug,\n            }),\n        [getNodePosition, points, width, height, margin, debug]\n    )\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n\nexport const useMeshEvents = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    delaunay,\n    setCurrent: setCurrentNode,\n    margin = defaultMargin,\n    detectionRadius = Infinity,\n    isInteractive = true,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    delaunay: Delaunay<Node>\n    setCurrent?: (node: Node | null) => void\n    margin?: Margin\n    detectionRadius?: number\n    isInteractive?: boolean\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n}) => {\n    // Store the index of the current point and the current node.\n    const [current, setCurrent] = useState<[number, Node] | null>(null)\n\n    // Keep track of the previous index and node, this is needed as we don't have enter/leave events\n    // for each node because we use a single rect element to capture events.\n    const previous = useRef<[number, Node] | null>(null)\n\n    useEffect(() => {\n        previous.current = current\n    }, [previous, current])\n\n    const findNode = useCallback(\n        (event: MouseEvent<ElementType> | TouchEvent<ElementType>): null | [number, Node] => {\n            if (!elementRef.current || nodes.length === 0) return null\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n\n            let index: number | null = delaunay.find(x, y)\n            let node = index !== undefined ? nodes[index] : null\n\n            if (node && detectionRadius !== Infinity) {\n                const [nodeX, nodeY] = getNodePosition(node)\n                if (getDistance(x, y, nodeX + margin.left, nodeY + margin.top) > detectionRadius) {\n                    index = null\n                    node = null\n                }\n            }\n\n            if (index === null || node === null) return null\n\n            return [index, node]\n        },\n        [elementRef, delaunay, nodes, getNodePosition, margin, detectionRadius]\n    )\n\n    const { showTooltipAt, showTooltipFromEvent, hideTooltip } = useTooltip()\n    const showTooltip = useMemo(() => {\n        if (!tooltip) return undefined\n\n        if (tooltipPosition === 'cursor') {\n            // Following the cursor.\n            return (node: Node, event: MouseEvent<ElementType>) => {\n                showTooltipFromEvent(tooltip(node), event, tooltipAnchor)\n            }\n        }\n\n        // Fixed at the node's position.\n        return (node: Node) => {\n            const [x, y] = getNodePosition(node)\n            showTooltipAt(tooltip(node), [x + margin.left, y + margin.top], tooltipAnchor)\n        }\n    }, [\n        showTooltipAt,\n        showTooltipFromEvent,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n        getNodePosition,\n        margin,\n    ])\n\n    // Mouse enter only occurs when entering the main element,\n    // not for each node.\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n            setCurrentNode?.(match ? match[1] : null)\n\n            if (match) {\n                const node = match[1]\n\n                showTooltip?.(node, event)\n                onMouseEnter?.(match[1], event)\n            }\n        },\n        [findNode, setCurrent, setCurrentNode, showTooltip, onMouseEnter]\n    )\n\n    // Handle mouse enter/move/leave, relying on `previous` to simulate events.\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) {\n                const [index, node] = match\n\n                setCurrentNode?.(node)\n                showTooltip?.(node, event)\n\n                if (previous.current) {\n                    const [previousIndex, previousNode] = previous.current\n                    if (index !== previousIndex) {\n                        // Simulate an enter event if the previous index is different.\n                        onMouseLeave?.(previousNode, event)\n                    } else {\n                        // If it's the same, trigger a regular move event.\n                        onMouseMove?.(node, event)\n                    }\n                } else {\n                    onMouseEnter?.(node, event)\n                }\n            } else {\n                setCurrentNode?.(null)\n                hideTooltip?.()\n\n                if (previous.current) {\n                    // Simulate a leave event if there's a previous node.\n                    onMouseLeave?.(previous.current[1], event)\n                }\n            }\n        },\n        [\n            findNode,\n            setCurrent,\n            setCurrentNode,\n            previous,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            showTooltip,\n            hideTooltip,\n        ]\n    )\n\n    // Mouse leave only occurs when leaving the main element,\n    // not for each node.\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            setCurrent(null)\n            setCurrentNode?.(null)\n\n            hideTooltip()\n\n            if (onMouseLeave && previous.current) {\n                onMouseLeave(previous.current[1], event)\n            }\n        },\n        [setCurrent, setCurrentNode, previous, hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseDown?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseUp?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onDoubleClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchStart?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchMove?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrent(null)\n                setCurrentNode?.(null)\n            }\n\n            if (onTouchEnd && previous.current) {\n                onTouchEnd(previous.current[1], event)\n            }\n        },\n        [enableTouchCrosshair, setCurrent, setCurrentNode, onTouchEnd, previous]\n    )\n\n    return {\n        current,\n        handleMouseEnter: isInteractive ? handleMouseEnter : undefined,\n        handleMouseMove: isInteractive ? handleMouseMove : undefined,\n        handleMouseLeave: isInteractive ? handleMouseLeave : undefined,\n        handleMouseDown: isInteractive ? handleMouseDown : undefined,\n        handleMouseUp: isInteractive ? handleMouseUp : undefined,\n        handleClick: isInteractive ? handleClick : undefined,\n        handleDoubleClick: isInteractive ? handleDoubleClick : undefined,\n        handleTouchStart: isInteractive ? handleTouchStart : undefined,\n        handleTouchMove: isInteractive ? handleTouchMove : undefined,\n        handleTouchEnd: isInteractive ? handleTouchEnd : undefined,\n    }\n}\n\n/**\n * Compute a voronoi mesh and corresponding events.\n */\nexport const useMesh = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition,\n    width,\n    height,\n    margin = defaultMargin,\n    isInteractive = true,\n    detectionRadius = Infinity,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug = false,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    width: number\n    height: number\n    margin?: Margin\n    isInteractive?: boolean\n    detectionRadius?: number\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    debug?: boolean\n}) => {\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        current,\n    } = useMeshEvents<Node, ElementType>({\n        elementRef,\n        nodes,\n        margin,\n        setCurrent,\n        delaunay,\n        detectionRadius,\n        isInteractive,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    return {\n        delaunay,\n        voronoi,\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n    }\n}\n","import { createElement, Fragment, ReactNode, forwardRef, Ref } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'> & {\n        forwardedRef: Ref<SVGSVGElement>\n    }\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n    forwardedRef,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = forwardRef(\n    (\n        {\n            theme,\n            ...props\n        }: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n            Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container isInteractive={false} animate={false} theme={theme}>\n            <InnerVoronoi {...props} forwardedRef={ref} />\n        </Container>\n    )\n)\n","import { forwardRef, Ref } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = ResponsiveProps<\n    Partial<Omit<VoronoiSvgProps, 'data'>> & Pick<VoronoiSvgProps, 'data'>\n>\n\nexport const ResponsiveVoronoi = forwardRef(\n    (\n        { defaultWidth, defaultHeight, onResize, debounceResize, ...props }: ResponsiveVoronoiProps,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <Voronoi {...props} width={width} height={height} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n)\n","import { useMemo, useRef } from 'react'\nimport { Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\nimport { useVoronoiMesh, useMeshEvents } from './hooks'\nimport { NodeMouseHandler, NodePositionAccessor, NodeTouchHandler } from './types'\nimport { defaultMargin, defaultTooltipAnchor, defaultTooltipPosition } from './defaults'\n\ninterface MeshProps<Node> {\n    nodes: Node[]\n    width: number\n    height: number\n    margin?: Margin\n    getNodePosition?: NodePositionAccessor<Node>\n    // Can be used in case you want to keep track of the current node externally,\n    // the current node being the last hovered node.\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    // Restrict the node detection to a given radius, default to `Infinity`.\n    detectionRadius?: number\n    // If specified, tooltips are going to be handled automatically.\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    // Display the voronoi mesh for debugging purpose.\n    debug?: boolean\n}\n\nexport const Mesh = <Node,>({\n    nodes,\n    width,\n    height,\n    margin = defaultMargin,\n    getNodePosition,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    detectionRadius = Infinity,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug,\n}: MeshProps<Node>) => {\n    const elementRef = useRef<SVGRectElement | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n    } = useMeshEvents<Node, SVGRectElement>({\n        elementRef,\n        nodes,\n        delaunay,\n        margin,\n        detectionRadius,\n        setCurrent,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        enableTouchCrosshair,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) return voronoi.render()\n        return undefined\n    }, [debug, voronoi])\n\n    return (\n        <g ref={elementRef} transform={`translate(${-margin.left},${-margin.top})`}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {detectionRadius < Infinity && (\n                        <path\n                            stroke=\"red\"\n                            strokeWidth={0.35}\n                            fill=\"none\"\n                            d={delaunay.renderPoints(undefined, detectionRadius)}\n                        />\n                    )}\n                    {/* highlight the current cell */}\n                    {current && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(current[0])} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={margin.left + width + margin.right}\n                height={margin.top + height + margin.bottom}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onMouseDown={handleMouseDown}\n                onMouseUp={handleMouseUp}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n                onDoubleClick={handleDoubleClick}\n            />\n        </g>\n    )\n}\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderDelaunayPointsToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    delaunay: Delaunay<Delaunay.Point>,\n    radius: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.15\n    ctx.beginPath()\n    delaunay.renderPoints(ctx, radius)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'pink'\n    ctx.fill()\n\n    ctx.restore()\n}\n\nexport const renderDebugToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        delaunay,\n        voronoi,\n        detectionRadius,\n        index,\n    }: {\n        delaunay: Delaunay<Delaunay.Point>\n        voronoi: Voronoi<Delaunay.Point>\n        detectionRadius: number\n        index: number | null\n    }\n) => {\n    renderVoronoiToCanvas(ctx, voronoi)\n\n    if (detectionRadius < Infinity) {\n        renderDelaunayPointsToCanvas(ctx, delaunay, detectionRadius)\n    }\n\n    if (index !== null) {\n        renderVoronoiCellToCanvas(ctx, voronoi, index)\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAEO,IAAMA,CAAA,GAAsB;IAC/BC,OAAA,EAAS,CAAC,GAAG;IACbC,OAAA,EAAS,CAAC,GAAG;IACbC,MAAA,EAAQ,CAAC,SAAS,SAAS,UAAU;IACrCC,WAAA,GAAa;IACbC,aAAA,EAAe;IACfC,aAAA,EAAe;IACfC,WAAA,GAAa;IACbC,aAAA,EAAe;IACfC,aAAA,EAAe;IACfC,YAAA,GAAc;IACdC,SAAA,EAAW;IACXC,UAAA,EAAY;IACZC,IAAA,EAAM;EAAA;ECZGC,CAAA,GAA8B,SAAAC,CAACC,CAAA;IAG3C,OAA6B,CAACA,CAAA,CAAKC,CAAA,EAAGD,CAAA,CAAKE,CAAA,CAAE;EAAA;EAEjCC,CAAA,GAAwBC,CAAA;EAExBC,CAAA,GAA0C;EAC1CC,CAAA,GAAsC;ECEtCC,CAAA,GAAoB,SAAAC,CAAHR,CAAA;IAQJ,IAPtBS,CAAA,GAAMT,CAAA,CAANU,MAAA;MAAMC,CAAA,GAAAX,CAAA,CACNY,eAAA;MAAAC,CAAA,QAAkB,MAAHF,CAAA,GAAGb,CAAA,GAA2Ba,CAAA;MAAAG,CAAA,GAAAd,CAAA,CAC7Ce,MAAA;MAAAC,CAAA,QAAS,MAAHF,CAAA,GAAGX,CAAA,GAAaW,CAAA;IAMtB,OAAOL,CAAA,CAAOQ,GAAA,CAAI,UAAAjB,CAAA;MACd,IAAAS,CAAA,GAAeI,CAAA,CAAgBb,CAAA;QAAxBW,CAAA,GAACF,CAAA;QAAEK,CAAA,GAACL,CAAA;MAEX,OAAO,CAACE,CAAA,GAAIK,CAAA,CAAOE,IAAA,EAAMJ,CAAA,GAAIE,CAAA,CAAOG,GAAA,CACxC;IAAA,EACJ;EAAA;EAEaC,CAAA,GAAc,SAAAC,CAAHrB,CAAA;IAYlB,IAXFS,CAAA,GAAMT,CAAA,CAANU,MAAA;MACAC,CAAA,GAAKX,CAAA,CAALsB,KAAA;MACAT,CAAA,GAAMb,CAAA,CAANuB,MAAA;MAAMT,CAAA,GAAAd,CAAA,CACNe,MAAA;MAAAC,CAAA,QAAS,MAAHF,CAAA,GAAGX,CAAA,GAAaW,CAAA;MACtBU,CAAA,GAAKxB,CAAA,CAALyB,KAAA;MAQMC,CAAA,GAAWC,CAAA,CAASC,IAAA,CAAKnB,CAAA;MACzBL,CAAA,GAAUoB,CAAA,GACVE,CAAA,CAASG,OAAA,CAAQ,CACb,GACA,GACAb,CAAA,CAAOE,IAAA,GAAOP,CAAA,GAAQK,CAAA,CAAOc,KAAA,EAC7Bd,CAAA,CAAOG,GAAA,GAAMN,CAAA,GAASG,CAAA,CAAOe,MAAA,UAEjC;IAEN,OAAO;MAAErB,MAAA,EAAAD,CAAA;MAAQuB,QAAA,EAAAN,CAAA;MAAUG,OAAA,EAAAzB;IAAA,CAC/B;EAAA;ECtBa6B,CAAA,GAAiB,SAAAC,CAAHzB,CAAA;IAAA,IACvBE,CAAA,GAAMF,CAAA,CAANC,MAAA;MAAMG,CAAA,GAAAJ,CAAA,CACNG,eAAA;MAAAE,CAAA,QAAkB,MAAHD,CAAA,GAAGf,CAAA,GAA2Be,CAAA;MAC7CG,CAAA,GAAKP,CAAA,CAALa,KAAA;MACAE,CAAA,GAAMf,CAAA,CAANc,MAAA;MAAMG,CAAA,GAAAjB,CAAA,CACNM,MAAA;MAAAX,CAAA,QAAS,MAAHsB,CAAA,GAAGvB,CAAA,GAAauB,CAAA;MACtBS,CAAA,GAAK1B,CAAA,CAALgB,KAAA;IAAK,OAYLzB,CAAA,CACI;MAAA,OACIoB,CAAA,CAAY;QACRV,MAAA,EAAQH,CAAA,CAAwB;UAAEG,MAAA,EAAAC,CAAA;UAAQI,MAAA,EAAAX,CAAA;UAAQQ,eAAA,EAAAE;QAAA;QAClDQ,KAAA,EAAAN,CAAA;QACAO,MAAA,EAAAC,CAAA;QACAT,MAAA,EAAAX,CAAA;QACAqB,KAAA,EAAAU;MAAA,EACF;IAAA,GACN,CAACrB,CAAA,EAAiBH,CAAA,EAAQK,CAAA,EAAOQ,CAAA,EAAQpB,CAAA,EAAQ+B,CAAA,EACpD;EAAA;EAEQlC,CAAA,GAAa,SAAAmC,CAAH3B,CAAA;IAYjB,IAXFE,CAAA,GAAIF,CAAA,CAAJ4B,IAAA;MACAxB,CAAA,GAAKJ,CAAA,CAALa,KAAA;MACAR,CAAA,GAAML,CAAA,CAANc,MAAA;MACAP,CAAA,GAAOP,CAAA,CAAPxB,OAAA;MACAuC,CAAA,GAAOf,CAAA,CAAPvB,OAAA;MAQMwC,CAAA,GAAS1B,CAAA,CAAQ;QAAA,OAAMsC,CAAA,GAAcC,MAAA,CAAOvB,CAAA,EAASwB,KAAA,CAAM,CAAC,GAAG3B,CAAA,EAAO;MAAA,GAAE,CAACG,CAAA,EAASH,CAAA;MAClFT,CAAA,GAASJ,CAAA,CACX;QAAA,OAAMsC,CAAA,GAAcC,MAAA,CAAOf,CAAA,EAASgB,KAAA,CAAM,CAAC,GAAG1B,CAAA,EAAQ;MAAA,GACtD,CAACU,CAAA,EAASV,CAAA;MAGRqB,CAAA,GAASnC,CAAA,CACX;QAAA,OACIW,CAAA,CAAKM,GAAA,CAAI,UAAAjB,CAAA;UAAC,OAAK;YACXC,CAAA,EAAGyB,CAAA,CAAO1B,CAAA,CAAEC,CAAA;YACZC,CAAA,EAAGE,CAAA,CAAOJ,CAAA,CAAEE,CAAA;YACZmC,IAAA,EAAMrC;UAAA,CACT;QAAA,EAAE;MAAA,GACP,CAACW,CAAA,EAAMe,CAAA,EAAQtB,CAAA;IAGnB,OAAOJ,CAAA,CAAQ;MACX,IAAMA,CAAA,GAAW2B,CAAA,CAASC,IAAA,CAAKO,CAAA,CAAOlB,GAAA,CAAI,UAAAjB,CAAA;UAAC,OAAI,CAACA,CAAA,CAAEC,CAAA,EAAGD,CAAA,CAAEE,CAAA,CAAE;QAAA;QACnDO,CAAA,GAAUT,CAAA,CAAS6B,OAAA,CAAQ,CAAC,GAAG,GAAGhB,CAAA,EAAOC,CAAA;MAE/C,OAAO;QACHJ,MAAA,EAAAyB,CAAA;QACAH,QAAA,EAAAhC,CAAA;QACA6B,OAAA,EAAApB;MAAA,CAEP;IAAA,GAAE,CAAC0B,CAAA,EAAQtB,CAAA,EAAOC,CAAA,EACvB;EAAA;EAKa2B,CAAA,GAAyB,SAAAC,CAAHjC,CAAA;IAAA,IAC/BE,CAAA,GAAMF,CAAA,CAANC,MAAA;MACAG,CAAA,GAAQJ,CAAA,CAARuB,QAAA;MACAlB,CAAA,GAAOL,CAAA,CAAPoB,OAAA;IAAO,OAEP7B,CAAA,CACI;MAAA,OAAO;QACHU,MAAA,EAAAC,CAAA;QACAqB,QAAA,EAAAnB,CAAA;QACAgB,OAAA,EAAAf;MAAA,CACF;IAAA,GACF,CAACH,CAAA,EAAQE,CAAA,EAAUC,CAAA,EACtB;EAAA;EAEQ6B,CAAA,GAAgB,SAAAC,CAAH5B,CAAA;IA8CpB,IA7CFQ,CAAA,GAAUR,CAAA,CAAV6B,UAAA;MACAnB,CAAA,GAAKV,CAAA,CAAL8B,KAAA;MAAK1C,CAAA,GAAAY,CAAA,CACLJ,eAAA;MAAAmC,CAAA,QAAkB,MAAH3C,CAAA,GAAGN,CAAA,GAA2BM,CAAA;MAC7C4C,CAAA,GAAQhC,CAAA,CAARgB,QAAA;MACYiB,CAAA,GAAcjC,CAAA,CAA1BkC,UAAA;MAAUC,CAAA,GAAAnC,CAAA,CACVD,MAAA;MAAAuB,CAAA,QAAS,MAAHa,CAAA,GAAGhD,CAAA,GAAagD,CAAA;MAAAxB,CAAA,GAAAX,CAAA,CACtBoC,eAAA;MAAAC,CAAA,QAAkB,MAAH1B,CAAA,GAAG,QAAQA,CAAA;MAAA2B,CAAA,GAAAtC,CAAA,CAC1BuC,aAAA;MAAAC,CAAA,QAAgB,MAAHF,CAAA,IAAOA,CAAA;MACpBG,CAAA,GAAYzC,CAAA,CAAZ0C,YAAA;MACAxD,CAAA,GAAWc,CAAA,CAAX2C,WAAA;MACA3E,CAAA,GAAYgC,CAAA,CAAZ4C,YAAA;MACArD,CAAA,GAAWS,CAAA,CAAX6C,WAAA;MACAzC,CAAA,GAASJ,CAAA,CAAT8C,SAAA;MACA7B,CAAA,GAAOjB,CAAA,CAAP+C,OAAA;MACA9D,CAAA,GAAae,CAAA,CAAbgD,aAAA;MACAvB,CAAA,GAAYzB,CAAA,CAAZiD,YAAA;MACAtB,CAAA,GAAW3B,CAAA,CAAXkD,WAAA;MACAC,CAAA,GAAUnD,CAAA,CAAVoD,UAAA;MAAUC,CAAA,GAAArD,CAAA,CACVsD,oBAAA;MAAAC,CAAA,QAAuB,MAAHF,CAAA,IAAQA,CAAA;MAC5BG,CAAA,GAAOxD,CAAA,CAAPyD,OAAA;MAAOC,CAAA,GAAA1D,CAAA,CACP2D,eAAA;MAAAC,CAAA,QAAkB,MAAHF,CAAA,GAAGrE,CAAA,GAAsBqE,CAAA;MAAAG,CAAA,GAAA7D,CAAA,CACxC8D,aAAA;MAAAC,CAAA,QAAgB,MAAHF,CAAA,GAAGvE,CAAA,GAAoBuE,CAAA;MA0BpCG,CAAA,GAA8BvE,CAAA,CAAgC;MAAvDwE,CAAA,GAAOD,CAAA;MAAEE,CAAA,GAAUF,CAAA;MAIpBG,CAAA,GAAWxE,CAAA,CAA8B;IAE/CE,CAAA,CAAU;MACNsE,CAAA,CAASC,OAAA,GAAUH,CACvB;IAAA,GAAG,CAACE,CAAA,EAAUF,CAAA;IAEd,IAAMI,CAAA,GAAWvE,CAAA,CACb,UAACd,CAAA;QACG,KAAKwB,CAAA,CAAW4D,OAAA,IAA4B,MAAjB1D,CAAA,CAAM4D,MAAA,EAAc,OAAO;QAEtD,IAAA7E,CAAA,GAAe0B,CAAA,CAAkBX,CAAA,CAAW4D,OAAA,EAASpF,CAAA;UAA9CW,CAAA,GAACF,CAAA;UAAEI,CAAA,GAACJ,CAAA;UAEPK,CAAA,GAAuBkC,CAAA,CAASuC,IAAA,CAAK5E,CAAA,EAAGE,CAAA;UACxCG,CAAA,QAAiB,MAAVF,CAAA,GAAsBY,CAAA,CAAMZ,CAAA,IAAS;QAEhD,IAAIE,CAAA,IAAQqC,CAAA,KAAoB,OAAU;UACtC,IAAAjD,CAAA,GAAuB2C,CAAA,CAAgB/B,CAAA;YAAhCiC,CAAA,GAAK7C,CAAA;YAAE+C,CAAA,GAAK/C,CAAA;UACfoF,CAAA,CAAY7E,CAAA,EAAGE,CAAA,EAAGoC,CAAA,GAAQX,CAAA,CAAOpB,IAAA,EAAMiC,CAAA,GAAQb,CAAA,CAAOnB,GAAA,IAAOkC,CAAA,KAC7DvC,CAAA,GAAQ,MACRE,CAAA,GAAO,KAEf;QAAA;QAEA,OAAc,SAAVF,CAAA,IAA2B,SAATE,CAAA,GAAsB,OAErC,CAACF,CAAA,EAAOE,CAAA,CACnB;MAAA,GACA,CAACQ,CAAA,EAAYwB,CAAA,EAAUtB,CAAA,EAAOqB,CAAA,EAAiBT,CAAA,EAAQe,CAAA;MAG3DoC,CAAA,GAA6DC,CAAA;MAArDC,CAAA,GAAaF,CAAA,CAAbG,aAAA;MAAeC,CAAA,GAAoBJ,CAAA,CAApBK,oBAAA;MAAsBC,CAAA,GAAWN,CAAA,CAAXO,WAAA;MACvCC,CAAA,GAAcjG,CAAA,CAAQ;QACxB,IAAKwE,CAAA,EAEL,OAAwB,aAApBI,CAAA,GAEO,UAAC5E,CAAA,EAAYS,CAAA;UAChBoF,CAAA,CAAqBrB,CAAA,CAAQxE,CAAA,GAAOS,CAAA,EAAOsE,CAAA;QAAA,IAK5C,UAAC/E,CAAA;UACJ,IAAAS,CAAA,GAAesC,CAAA,CAAgB/C,CAAA;YAAxBW,CAAA,GAACF,CAAA;YAAEI,CAAA,GAACJ,CAAA;UACXkF,CAAA,CAAcnB,CAAA,CAAQxE,CAAA,GAAO,CAACW,CAAA,GAAI2B,CAAA,CAAOpB,IAAA,EAAML,CAAA,GAAIyB,CAAA,CAAOnB,GAAA,GAAM4D,CAAA;QAAA,CAExE;MAAA,GAAG,CACCY,CAAA,EACAE,CAAA,EACArB,CAAA,EACAI,CAAA,EACAG,CAAA,EACAhC,CAAA,EACAT,CAAA;MAKE4D,CAAA,GAAmBpF,CAAA,CACrB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAKvB,IAHAkF,CAAA,CAAWzE,CAAA,GACG,QAAdwC,CAAA,IAAAA,CAAA,CAAiBxC,CAAA,GAAQA,CAAA,CAAM,KAAK,OAEhCA,CAAA,EAAO;UACP,IAAME,CAAA,GAAOF,CAAA,CAAM;UAAA,QAEnBwF,CAAA,IAAAA,CAAA,CAActF,CAAA,EAAMX,CAAA,GACR,QAAZyD,CAAA,IAAAA,CAAA,CAAehD,CAAA,CAAM,IAAIT,CAAA,CAC7B;QAAA;MACJ,GACA,CAACqF,CAAA,EAAUH,CAAA,EAAYjC,CAAA,EAAgBgD,CAAA,EAAaxC,CAAA;MAIlD0C,CAAA,GAAkBrF,CAAA,CACpB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAIvB,IAFAkF,CAAA,CAAWzE,CAAA,GAEPA,CAAA,EAAO;UACP,IAAOE,CAAA,GAAeF,CAAA,CAAK;YAAbI,CAAA,GAAQJ,CAAA,CAAK;UAK3B,IAHA,QAAAwC,CAAA,IAAAA,CAAA,CAAiBpC,CAAA,WACjBoF,CAAA,IAAAA,CAAA,CAAcpF,CAAA,EAAMb,CAAA,GAEhBmF,CAAA,CAASC,OAAA,EAAS;YAClB,IAAAtE,CAAA,GAAsCqE,CAAA,CAASC,OAAA;cAAxCpE,CAAA,GAAaF,CAAA;cAAEU,CAAA,GAAYV,CAAA;YAC9BH,CAAA,KAAUK,CAAA,WAEVhC,CAAA,IAAAA,CAAA,CAAewC,CAAA,EAAcxB,CAAA,YAG7BE,CAAA,IAAAA,CAAA,CAAcW,CAAA,EAAMb,CAAA,CAE5B;UAAA,eACIyD,CAAA,IAAAA,CAAA,CAAe5C,CAAA,EAAMb,CAAA,CAE7B;QAAA,OACI,QAAAiD,CAAA,IAAAA,CAAA,CAAiB,OACN,QAAX8C,CAAA,IAAAA,CAAA,IAEIZ,CAAA,CAASC,OAAA,KAEG,QAAZpG,CAAA,IAAAA,CAAA,CAAemG,CAAA,CAASC,OAAA,CAAQ,IAAIpF,CAAA,EAG/C;MAAA,GACD,CACIqF,CAAA,EACAH,CAAA,EACAjC,CAAA,EACAkC,CAAA,EACA1B,CAAA,EACAvD,CAAA,EACAlB,CAAA,EACAiH,CAAA,EACAF,CAAA;MAMFK,EAAA,GAAmBtF,CAAA,CACrB,UAACd,CAAA;QACGkF,CAAA,CAAW,OACX,QAAAjC,CAAA,IAAAA,CAAA,CAAiB,OAEjB8C,CAAA,IAEI/G,CAAA,IAAgBmG,CAAA,CAASC,OAAA,IACzBpG,CAAA,CAAamG,CAAA,CAASC,OAAA,CAAQ,IAAIpF,CAAA,CAE1C;MAAA,GACA,CAACkF,CAAA,EAAYjC,CAAA,EAAgBkC,CAAA,EAAUY,CAAA,EAAa/G,CAAA;MAGlDqH,EAAA,GAAkBvF,CAAA,CACpB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEvBkF,CAAA,CAAWzE,CAAA,GAEPA,CAAA,KAAkB,QAAXF,CAAA,IAAAA,CAAA,CAAcE,CAAA,CAAM,IAAIT,CAAA,EACtC;MAAA,GACD,CAACqF,CAAA,EAAUH,CAAA,EAAY3E,CAAA;MAGrB+F,EAAA,GAAgBxF,CAAA,CAClB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEvBkF,CAAA,CAAWzE,CAAA,GAEPA,CAAA,KAAgB,QAATW,CAAA,IAAAA,CAAA,CAAYX,CAAA,CAAM,IAAIT,CAAA,EACpC;MAAA,GACD,CAACqF,CAAA,EAAUH,CAAA,EAAY9D,CAAA;MAGrBmF,EAAA,GAAczF,CAAA,CAChB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEvBkF,CAAA,CAAWzE,CAAA,GAEPA,CAAA,KAAc,QAAPwB,CAAA,IAAAA,CAAA,CAAUxB,CAAA,CAAM,IAAIT,CAAA,EAClC;MAAA,GACD,CAACqF,CAAA,EAAUH,CAAA,EAAYjD,CAAA;MAGrBuE,EAAA,GAAoB1F,CAAA,CACtB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEvBkF,CAAA,CAAWzE,CAAA,GAEPA,CAAA,KAAoB,QAAbR,CAAA,IAAAA,CAAA,CAAgBQ,CAAA,CAAM,IAAIT,CAAA,EACxC;MAAA,GACD,CAACqF,CAAA,EAAUH,CAAA,EAAYjF,CAAA;MAGrBwG,EAAA,GAAmB3F,CAAA,CACrB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEnBuE,CAAA,KACAW,CAAA,CAAWzE,CAAA,GACG,QAAdwC,CAAA,IAAAA,CAAA,CAAiBxC,CAAA,GAAQA,CAAA,CAAM,KAAK,QAGpCA,CAAA,KAAmB,QAAZgC,CAAA,IAAAA,CAAA,CAAehC,CAAA,CAAM,IAAIT,CAAA,EACxC;MAAA,GACA,CAACqF,CAAA,EAAUH,CAAA,EAAYjC,CAAA,EAAgBsB,CAAA,EAAsB9B,CAAA;MAG3DiE,EAAA,GAAkB5F,CAAA,CACpB,UAACd,CAAA;QACG,IAAMS,CAAA,GAAQ4E,CAAA,CAASrF,CAAA;QAEnBuE,CAAA,KACAW,CAAA,CAAWzE,CAAA,GACG,QAAdwC,CAAA,IAAAA,CAAA,CAAiBxC,CAAA,GAAQA,CAAA,CAAM,KAAK,QAGpCA,CAAA,KAAkB,QAAXkC,CAAA,IAAAA,CAAA,CAAclC,CAAA,CAAM,IAAIT,CAAA,EACvC;MAAA,GACA,CAACqF,CAAA,EAAUH,CAAA,EAAYjC,CAAA,EAAgBsB,CAAA,EAAsB5B,CAAA;MAG3DgE,EAAA,GAAiB7F,CAAA,CACnB,UAACd,CAAA;QACOuE,CAAA,KACAW,CAAA,CAAW,OACX,QAAAjC,CAAA,IAAAA,CAAA,CAAiB,QAGjBkB,CAAA,IAAcgB,CAAA,CAASC,OAAA,IACvBjB,CAAA,CAAWgB,CAAA,CAASC,OAAA,CAAQ,IAAIpF,CAAA,CAExC;MAAA,GACA,CAACuE,CAAA,EAAsBW,CAAA,EAAYjC,CAAA,EAAgBkB,CAAA,EAAYgB,CAAA;IAGnE,OAAO;MACHC,OAAA,EAAAH,CAAA;MACA2B,gBAAA,EAAkBpD,CAAA,GAAgB0C,CAAA,QAAmB;MACrDW,eAAA,EAAiBrD,CAAA,GAAgB2C,CAAA,QAAkB;MACnDW,gBAAA,EAAkBtD,CAAA,GAAgB4C,EAAA,QAAmB;MACrDW,eAAA,EAAiBvD,CAAA,GAAgB6C,EAAA,QAAkB;MACnDW,aAAA,EAAexD,CAAA,GAAgB8C,EAAA,QAAgB;MAC/CW,WAAA,EAAazD,CAAA,GAAgB+C,EAAA,QAAc;MAC3CW,iBAAA,EAAmB1D,CAAA,GAAgBgD,EAAA,QAAoB;MACvDW,gBAAA,EAAkB3D,CAAA,GAAgBiD,EAAA,QAAmB;MACrDW,eAAA,EAAiB5D,CAAA,GAAgBkD,EAAA,QAAkB;MACnDW,cAAA,EAAgB7D,CAAA,GAAgBmD,EAAA,QAAiB;IAAA,CAEzD;EAAA;EAKaxC,CAAA,GAAU,SAAAmD,CAAHtH,CAAA;IA0Cd,IAzCFS,CAAA,GAAUT,CAAA,CAAV6C,UAAA;MACAlC,CAAA,GAAKX,CAAA,CAAL8C,KAAA;MACAjC,CAAA,GAAeb,CAAA,CAAfY,eAAA;MACAE,CAAA,GAAKd,CAAA,CAALsB,KAAA;MACAN,CAAA,GAAMhB,CAAA,CAANuB,MAAA;MAAMC,CAAA,GAAAxB,CAAA,CACNe,MAAA;MAAAW,CAAA,QAAS,MAAHF,CAAA,GAAGrB,CAAA,GAAaqB,CAAA;MAAApB,CAAA,GAAAJ,CAAA,CACtBuD,aAAA;MAAApB,CAAA,QAAgB,MAAH/B,CAAA,IAAOA,CAAA;MAAAoF,CAAA,GAAAxF,CAAA,CACpBoD,eAAA;MAAAL,CAAA,QAAkB,MAAHyC,CAAA,GAAG,QAAQA,CAAA;MAC1BxC,CAAA,GAAUhD,CAAA,CAAVkD,UAAA;MACAD,CAAA,GAAYjD,CAAA,CAAZ0D,YAAA;MACAP,CAAA,GAAWnD,CAAA,CAAX2D,WAAA;MACArB,CAAA,GAAYtC,CAAA,CAAZ4D,YAAA;MACAjC,CAAA,GAAW3B,CAAA,CAAX6D,WAAA;MACA6B,CAAA,GAAS1F,CAAA,CAAT8D,SAAA;MACAT,CAAA,GAAOrD,CAAA,CAAP+D,OAAA;MACAT,CAAA,GAAatD,CAAA,CAAbgE,aAAA;MACAR,CAAA,GAAOxD,CAAA,CAAPyE,OAAA;MAAOhB,CAAA,GAAAzD,CAAA,CACP2E,eAAA;MAAAzE,CAAA,QAAkB,MAAHuD,CAAA,GAAGpD,CAAA,GAAsBoD,CAAA;MAAAzE,CAAA,GAAAgB,CAAA,CACxC8E,aAAA;MAAAhF,CAAA,QAAgB,MAAHd,CAAA,GAAGsB,CAAA,GAAoBtB,CAAA;MAAAuB,CAAA,GAAAP,CAAA,CACpCyB,KAAA;MAuBAL,CAAA,GAA8Ba,CAAA,CAAqB;QAC/CvB,MAAA,EAAQC,CAAA;QACRC,eAAA,EAAAC,CAAA;QACAS,KAAA,EAAAR,CAAA;QACAS,MAAA,EAAAP,CAAA;QACAD,MAAA,EAAAW,CAAA;QACAD,KAAA,OA7BI,MAAHlB,CAAA,IAAQA;MAAA;MAuBLN,CAAA,GAAQmB,CAAA,CAARY,QAAA;MAAUS,CAAA,GAAOrB,CAAA,CAAPS,OAAA;MASlBsC,CAAA,GASIxB,CAAA,CAAiC;QACjCE,UAAA,EAAApC,CAAA;QACAqC,KAAA,EAAAnC,CAAA;QACAI,MAAA,EAAAW,CAAA;QACAwB,UAAA,EAAAF,CAAA;QACAhB,QAAA,EAAA/B,CAAA;QACAmD,eAAA,EAAAL,CAAA;QACAQ,aAAA,EAAApB,CAAA;QACAuB,YAAA,EAAAT,CAAA;QACAU,WAAA,EAAAR,CAAA;QACAS,YAAA,EAAAtB,CAAA;QACAuB,WAAA,EAAAlC,CAAA;QACAmC,SAAA,EAAA4B,CAAA;QACA3B,OAAA,EAAAV,CAAA;QACAW,aAAA,EAAAV,CAAA;QACAmB,OAAA,EAAAjB,CAAA;QACAmB,eAAA,EAAAzE,CAAA;QACA4E,aAAA,EAAAhF;MAAA;MAzBAuE,CAAA,GAAgBF,CAAA,CAAhByC,gBAAA;MACArC,CAAA,GAAeJ,CAAA,CAAf0C,eAAA;MACArC,CAAA,GAAgBL,CAAA,CAAhB2C,gBAAA;MACApC,CAAA,GAAeP,CAAA,CAAf4C,eAAA;MACAnC,CAAA,GAAaT,CAAA,CAAb6C,aAAA;MACAnC,CAAA,GAAWV,CAAA,CAAX8C,WAAA;MACAlC,CAAA,GAAiBZ,CAAA,CAAjB+C,iBAAA;IAsBJ,OAAO;MACHlF,QAAA,EAAA/B,CAAA;MACA4B,OAAA,EAAAY,CAAA;MACA2C,OAAA,EAxBOjB,CAAA,CAAPiB,OAAA;MAyBAwB,gBAAA,EAAAvC,CAAA;MACAwC,eAAA,EAAAtC,CAAA;MACAuC,gBAAA,EAAAtC,CAAA;MACAuC,eAAA,EAAArC,CAAA;MACAsC,aAAA,EAAApC,CAAA;MACAqC,WAAA,EAAApC,CAAA;MACAqC,iBAAA,EAAAnC;IAAA,CAER;EAAA;EAAAV,CAAA;EChfME,CAAA,GAAe,SAAAgD,CAAHvH,CAAA;IAmBO,IAlBrBS,CAAA,GAAIT,CAAA,CAAJqC,IAAA;MACA1B,CAAA,GAAKX,CAAA,CAALsB,KAAA;MACAT,CAAA,GAAMb,CAAA,CAANuB,MAAA;MACQT,CAAA,GAAad,CAAA,CAArBe,MAAA;MAAMC,CAAA,GAAAhB,CAAA,CACNb,MAAA;MAAAiB,CAAA,QAAM,MAAAY,CAAA,GAAGhC,CAAA,CAAoBG,MAAA,GAAM6B,CAAA;MAAAmB,CAAA,GAAAnC,CAAA,CACnCf,OAAA;MAAAuG,CAAA,QAAO,MAAArD,CAAA,GAAGnD,CAAA,CAAoBC,OAAA,GAAOkD,CAAA;MAAAY,CAAA,GAAA/C,CAAA,CACrCd,OAAA;MAAAiE,CAAA,QAAO,MAAAJ,CAAA,GAAG/D,CAAA,CAAoBE,OAAA,GAAO6D,CAAA;MAAAT,CAAA,GAAAtC,CAAA,CACrCZ,WAAA;MAAAuC,CAAA,QAAW,MAAAW,CAAA,GAAGtD,CAAA,CAAoBI,WAAA,GAAWkD,CAAA;MAAAoD,CAAA,GAAA1F,CAAA,CAC7CX,aAAA;MAAAiE,CAAA,QAAa,MAAAoC,CAAA,GAAG1G,CAAA,CAAoBK,aAAA,GAAaqG,CAAA;MAAAlC,CAAA,GAAAxD,CAAA,CACjDV,aAAA;MAAAmE,CAAA,QAAa,MAAAD,CAAA,GAAGxE,CAAA,CAAoBM,aAAA,GAAakE,CAAA;MAAAtD,CAAA,GAAAF,CAAA,CACjDT,WAAA;MAAAO,CAAA,QAAW,MAAAI,CAAA,GAAGlB,CAAA,CAAoBO,WAAA,GAAWW,CAAA;MAAAC,CAAA,GAAAH,CAAA,CAC7CR,aAAA;MAAAa,CAAA,QAAa,MAAAF,CAAA,GAAGnB,CAAA,CAAoBQ,aAAA,GAAaW,CAAA;MAAAG,CAAA,GAAAN,CAAA,CACjDP,aAAA;MAAAc,CAAA,QAAa,MAAAD,CAAA,GAAGtB,CAAA,CAAoBS,aAAA,GAAaa,CAAA;MAAAc,CAAA,GAAApB,CAAA,CACjDN,YAAA;MAAAuC,CAAA,QAAY,MAAAb,CAAA,GAAGpC,CAAA,CAAoBO,WAAA,GAAW6B,CAAA;MAAAuB,CAAA,GAAA3C,CAAA,CAC9CL,SAAA;MAAAwE,CAAA,QAAS,MAAAxB,CAAA,GAAG3D,CAAA,CAAoBW,SAAA,GAASgD,CAAA;MAAA0B,CAAA,GAAArE,CAAA,CACzCJ,UAAA;MAAA2E,CAAA,QAAU,MAAAF,CAAA,GAAGrF,CAAA,CAAoBY,UAAA,GAAUyE,CAAA;MAAAG,CAAA,GAAAxE,CAAA,CAC3CH,IAAA;MAAA6E,CAAA,QAAI,MAAAF,CAAA,GAAGxF,CAAA,CAAoBa,IAAA,GAAI2E,CAAA;MAC/BI,CAAA,GAAY5E,CAAA,CAAZwH,YAAA;MAEA3C,CAAA,GAAqE7B,CAAA,CACjErC,CAAA,EACAE,CAAA,EACAC,CAAA;MAHIiE,CAAA,GAAUF,CAAA,CAAV4C,UAAA;MAAYzC,CAAA,GAAWH,CAAA,CAAX6C,WAAA;MAAazC,CAAA,GAAMJ,CAAA,CAAN9D,MAAA;MAAQmE,CAAA,GAAUL,CAAA,CAAV8C,UAAA;MAAYxC,CAAA,GAAWN,CAAA,CAAX+C,WAAA;MAMrDvC,CAAA,GAAsCpF,CAAA,CAAW;QAC7CoC,IAAA,EAAA5B,CAAA;QACAa,KAAA,EAAO4D,CAAA;QACP3D,MAAA,EAAQ4D,CAAA;QACRlG,OAAA,EAAAuG,CAAA;QACAtG,OAAA,EAAAiE;MAAA;MALIsC,CAAA,GAAMJ,CAAA,CAAN3E,MAAA;MAAQiF,CAAA,GAAQN,CAAA,CAARrD,QAAA;MAAU6D,CAAA,GAAOR,CAAA,CAAPxD,OAAA;MAQpBkE,CAAA,GAA+C;QACjD8B,KAAA,EAAO;QACPC,KAAA,EAAO;QACPpH,MAAA,EAAQ;QACRqH,MAAA,EAAQ;MAAA;IAGRpG,CAAA,IAAevB,CAAA,CAAO4H,QAAA,CAAS,aAC/BjC,CAAA,CAAU8B,KAAA,GACNxE,CAAA;MAEI4E,MAAA,EAAQxE,CAAA;MACRyE,WAAA,EAAa5E,CAAA;MACb6E,IAAA,EAAK;MACLhG,CAAA,EAAGwD,CAAA,CAASyC,MAAA;IAAA,GAJR,WASZtI,CAAA,IAAeM,CAAA,CAAO4H,QAAA,CAAS,aAC/BjC,CAAA,CAAU+B,KAAA,GACNzE,CAAA;MAEIlB,CAAA,EAAG0D,CAAA,CAAQuC,MAAA;MACXD,IAAA,EAAK;MACLF,MAAA,EAAQ1H,CAAA;MACR2H,WAAA,EAAa7H;IAAA,GAJT,WASZ4B,CAAA,IAAgB7B,CAAA,CAAO4H,QAAA,CAAS,cAChCjC,CAAA,CAAUrF,MAAA,GACN2C,CAAA;MAEI4E,MAAA,EAAO;MACPE,IAAA,EAAM5D,CAAA;MACNpC,CAAA,EAAGwD,CAAA,CAAS0C,YAAA,MAAa,GAAWlE,CAAA,GAAY;IAAA,GAH5C,YAQZ/D,CAAA,CAAO4H,QAAA,CAAS,cAChBjC,CAAA,CAAUgC,MAAA,GACN1E,CAAA;MAEI8E,IAAA,EAAK;MACLF,MAAA,EAAQ1H,CAAA;MACR2H,WAAA,EAAa7H,CAAA;MACb8B,CAAA,EAAG0D,CAAA,CAAQyC,YAAA;IAAA,GAJP;IAShB,IAAMrC,CAAA,GAAexD,CAAA,CAAuB;MACxC/B,MAAA,EAAA+E,CAAA;MACAzD,QAAA,EAAA2D,CAAA;MACA9D,OAAA,EAAAgE;IAAA;IAGJ,OACIxC,CAAA,CAACJ,CAAA,EAAU;MACP3B,KAAA,EAAOyD,CAAA;MACPxD,MAAA,EAAQyD,CAAA;MACRjE,MAAA,EAAQkE,CAAA;MACRpF,IAAA,EAAM6E,CAAA;MACN6D,GAAA,EAAK3D,CAAA;MAAa4D,QAAA,EAEjBpI,CAAA,CAAOa,GAAA,CAAI,UAACjB,CAAA,EAAOS,CAAA;QAChB,YAA2C,MAAvCsF,CAAA,CAAU/F,CAAA,IACH+F,CAAA,CAAU/F,CAAA,IAGA,qBAAVA,CAAA,GACAqD,CAAA,CAAC7B,CAAA,EAAQ;UAAAgH,QAAA,EAAU9G,CAAA,CAAc1B,CAAA,EAAOiG,CAAA;QAAA,GAAzBxF,CAAA,IAGnB;MAAA;IAAA,EAIvB;EAAA;EAEa+D,CAAA,GAAUxD,CAAA,CACnB,UAAAhB,CAAA,EAMIS,CAAA;IAAuB,IAJnBE,CAAA,GAAKX,CAAA,CAALyI,KAAA;MACG5H,CAAA,GAAKX,CAAA,CAAAF,CAAA,EAAAqE,CAAA;IAAA,OAKZhB,CAAA,CAACN,CAAA,EAAS;MAACQ,aAAA,GAAe;MAAOmF,OAAA,GAAS;MAAOD,KAAA,EAAO9H,CAAA;MAAM6H,QAAA,EAC1DnF,CAAA,CAACkB,CAAA,EAAYd,CAAA,KAAK5C,CAAA,EAAK;QAAE2G,YAAA,EAAc/G;MAAA;IAAA,EAC/B;EAAA;EAAAiE,CAAA;EClIPE,CAAA,GAAoB5D,CAAA,CAC7B,UAAAhB,CAAA,EAEIS,CAAA;IAAuB,IADrBE,CAAA,GAAYX,CAAA,CAAZ2I,YAAA;MAAc9H,CAAA,GAAab,CAAA,CAAb4I,aAAA;MAAe9H,CAAA,GAAQd,CAAA,CAAR6I,QAAA;MAAU7H,CAAA,GAAchB,CAAA,CAAd8I,cAAA;MAAmBtH,CAAA,GAAKtB,CAAA,CAAAF,CAAA,EAAA0E,CAAA;IAAA,OAGjErB,CAAA,CAACF,CAAA,EAAiB;MACdwF,YAAA,EAAchI,CAAA;MACdiI,aAAA,EAAe/H,CAAA;MACfgI,QAAA,EAAU/H,CAAA;MACVgI,cAAA,EAAgB9H,CAAA;MAAewH,QAAA,EAE9B,SAAAA,CAAAxI,CAAA;QAAA,IAAGW,CAAA,GAAKX,CAAA,CAALsB,KAAA;UAAOT,CAAA,GAAMb,CAAA,CAANuB,MAAA;QAAM,OACb8B,CAAA,CAACmB,CAAA,EAAOf,CAAA,KAAKjC,CAAA,EAAK;UAAEF,KAAA,EAAOX,CAAA;UAAOY,MAAA,EAAQV,CAAA;UAAQ0H,GAAA,EAAK9H;QAAA,GAAO;MAAA;IAAA,EAElD;EAAA;ECcfoE,CAAA,GAAO,SAAAkE,CAAHtI,CAAA;IAuBM,IAtBnBI,CAAA,GAAKJ,CAAA,CAALqC,KAAA;MACAhC,CAAA,GAAKL,CAAA,CAALa,KAAA;MACAN,CAAA,GAAMP,CAAA,CAANc,MAAA;MAAMC,CAAA,GAAAf,CAAA,CACNM,MAAA;MAAAW,CAAA,QAAS,MAAHF,CAAA,GAAGrB,CAAA,GAAaqB,CAAA;MACtBpB,CAAA,GAAeK,CAAA,CAAfG,eAAA;MACAuB,CAAA,GAAU1B,CAAA,CAAVyC,UAAA;MACAsC,CAAA,GAAY/E,CAAA,CAAZiD,YAAA;MACAX,CAAA,GAAWtC,CAAA,CAAXkD,WAAA;MACAX,CAAA,GAAYvC,CAAA,CAAZmD,YAAA;MACAX,CAAA,GAAWxC,CAAA,CAAXoD,WAAA;MACAV,CAAA,GAAS1C,CAAA,CAATqD,SAAA;MACAxB,CAAA,GAAO7B,CAAA,CAAPsD,OAAA;MACApC,CAAA,GAAalB,CAAA,CAAbuD,aAAA;MACA0B,CAAA,GAAYjF,CAAA,CAAZwD,YAAA;MACAR,CAAA,GAAWhD,CAAA,CAAXyD,WAAA;MACAhE,CAAA,GAAUO,CAAA,CAAV2D,UAAA;MAAUpF,CAAA,GAAAyB,CAAA,CACV6D,oBAAA;MAAAxE,CAAA,QAAuB,MAAHd,CAAA,IAAQA,CAAA;MAAAuB,CAAA,GAAAE,CAAA,CAC5B2C,eAAA;MAAAhC,CAAA,QAAkB,MAAHb,CAAA,GAAG,QAAQA,CAAA;MAC1BN,CAAA,GAAOQ,CAAA,CAAPgE,OAAA;MAAOhC,CAAA,GAAAhC,CAAA,CACPkE,eAAA;MAAAR,CAAA,QAAkB,MAAH1B,CAAA,GAAGpC,CAAA,GAAsBoC,CAAA;MAAA4B,CAAA,GAAA5D,CAAA,CACxCqE,aAAA;MAAAP,CAAA,QAAgB,MAAHF,CAAA,GAAG/D,CAAA,GAAoB+D,CAAA;MACpCG,CAAA,GAAK/D,CAAA,CAALgB,KAAA;MAEMiD,CAAA,GAAa/D,CAAA,CAA8B;MAEjDiE,CAAA,GAA8B3C,CAAA,CAAqB;QAC/CvB,MAAA,EAAQG,CAAA;QACRD,eAAA,EAAAR,CAAA;QACAkB,KAAA,EAAAR,CAAA;QACAS,MAAA,EAAAP,CAAA;QACAD,MAAA,EAAAW,CAAA;QACAD,KAAA,EAAA+C;MAAA;MANIK,CAAA,GAAQD,CAAA,CAAR5C,QAAA;MAAU+C,CAAA,GAAOH,CAAA,CAAP/C,OAAA;MASlBmD,CAAA,GAYIrC,CAAA,CAAoC;QACpCE,UAAA,EAAA6B,CAAA;QACA5B,KAAA,EAAAjC,CAAA;QACAmB,QAAA,EAAA6C,CAAA;QACA9D,MAAA,EAAAW,CAAA;QACA0B,eAAA,EAAAhC,CAAA;QACA8B,UAAA,EAAAf,CAAA;QACAuB,YAAA,EAAA8B,CAAA;QACA7B,WAAA,EAAAZ,CAAA;QACAa,YAAA,EAAAZ,CAAA;QACAa,WAAA,EAAAZ,CAAA;QACAa,SAAA,EAAAX,CAAA;QACAY,OAAA,EAAAzB,CAAA;QACA0B,aAAA,EAAArC,CAAA;QACAsC,YAAA,EAAAyB,CAAA;QACAxB,WAAA,EAAAT,CAAA;QACAW,UAAA,EAAAlE,CAAA;QACAoE,oBAAA,EAAAxE,CAAA;QACA2E,OAAA,EAAAxE,CAAA;QACA0E,eAAA,EAAAR,CAAA;QACAW,aAAA,EAAAP;MAAA;MA/BAU,CAAA,GAAOD,CAAA,CAAPI,OAAA;MACAF,CAAA,GAAgBF,CAAA,CAAhB4B,gBAAA;MACAzB,CAAA,GAAeH,CAAA,CAAf6B,eAAA;MACAxB,CAAA,GAAgBL,CAAA,CAAhB8B,gBAAA;MACArB,CAAA,GAAeT,CAAA,CAAf+B,eAAA;MACApB,CAAA,GAAaX,CAAA,CAAbgC,aAAA;MACAnB,CAAA,GAAWb,CAAA,CAAXiC,WAAA;MACAlB,CAAA,GAAiBf,CAAA,CAAjBkC,iBAAA;MACAjB,CAAA,GAAgBjB,CAAA,CAAhBmC,gBAAA;MACAjB,CAAA,GAAelB,CAAA,CAAfoC,eAAA;MACAjB,CAAA,GAAcnB,CAAA,CAAdqC,cAAA;MAwBEjB,EAAA,GAAcpG,CAAA,CAAQ;QACxB,IAAIwE,CAAA,IAASO,CAAA,EAAS,OAAOA,CAAA,CAAQqD,MAAA,EAEzC;MAAA,GAAG,CAAC5D,CAAA,EAAOO,CAAA;IAEX,OACIzB,CAAA;MAAGiF,GAAA,EAAK7D,CAAA;MAAYsE,SAAA,EAAS,gBAAgBtH,CAAA,CAAOR,IAAA,UAASQ,CAAA,CAAOP,GAAA,GAAO;MAAAqH,QAAA,GACtEhE,CAAA,IAASO,CAAA,IACNzB,CAAA,CAAAE,CAAA;QAAAgF,QAAA,GACInF,CAAA;UAAMlB,CAAA,EAAGiE,EAAA;UAAa6B,MAAA,EAAO;UAAMC,WAAA,EAAa;UAAGe,OAAA,EAAS;QAAA,IAC3D7H,CAAA,GAAkB,SACfiC,CAAA;UACI4E,MAAA,EAAO;UACPC,WAAA,EAAa;UACbC,IAAA,EAAK;UACLhG,CAAA,EAAG0C,CAAA,CAASwD,YAAA,MAAa,GAAWjH,CAAA;QAAA,IAI3C6D,CAAA,IACG5B,CAAA;UAAM8E,IAAA,EAAK;UAAOc,OAAA,EAAS;UAAM9G,CAAA,EAAG4C,CAAA,CAAQmE,UAAA,CAAWjE,CAAA,CAAQ;QAAA;MAAA,IAK3E5B,CAAA;QACI,YAAS;QACT/B,KAAA,EAAOI,CAAA,CAAOR,IAAA,GAAOJ,CAAA,GAAQY,CAAA,CAAOI,KAAA;QACpCP,MAAA,EAAQG,CAAA,CAAOP,GAAA,GAAMH,CAAA,GAASU,CAAA,CAAOK,MAAA;QACrCoG,IAAA,EAAK;QACLc,OAAA,EAAS;QACTE,KAAA,EAAO;UAAEC,MAAA,EAAQ;QAAA;QACjB1F,YAAA,EAAcwB,CAAA;QACdvB,WAAA,EAAawB,CAAA;QACbvB,YAAA,EAAcyB,CAAA;QACdxB,WAAA,EAAa4B,CAAA;QACb3B,SAAA,EAAW6B,CAAA;QACX1B,YAAA,EAAcgC,CAAA;QACd/B,WAAA,EAAagC,CAAA;QACb9B,UAAA,EAAY+B,CAAA;QACZpC,OAAA,EAAS8B,CAAA;QACT7B,aAAA,EAAe+B;MAAA;IAAA,EAI/B;EAAA;ECtJahB,CAAA,GAAwB,SAAAsE,CACjCrJ,CAAA,EACAS,CAAA;IAEAT,CAAA,CAAIsJ,IAAA,IAEJtJ,CAAA,CAAIuJ,WAAA,GAAc,KAClBvJ,CAAA,CAAIwJ,SAAA,IACJ/I,CAAA,CAAQ2H,MAAA,CAAOpI,CAAA,GACfA,CAAA,CAAIyJ,WAAA,GAAc,OAClBzJ,CAAA,CAAI0J,SAAA,GAAY,GAChB1J,CAAA,CAAIiI,MAAA,IAEJjI,CAAA,CAAI2J,OAAA,EACR;EAAA;EAEa3E,CAAA,GAA+B,SAAA4E,CACxC5J,CAAA,EACAS,CAAA,EACAE,CAAA;IAEAX,CAAA,CAAIsJ,IAAA,IAEJtJ,CAAA,CAAIuJ,WAAA,GAAc,KAClBvJ,CAAA,CAAIwJ,SAAA,IACJ/I,CAAA,CAAS4H,YAAA,CAAarI,CAAA,EAAKW,CAAA,GAC3BX,CAAA,CAAIyJ,WAAA,GAAc,OAClBzJ,CAAA,CAAI0J,SAAA,GAAY,GAChB1J,CAAA,CAAIiI,MAAA,IAEJjI,CAAA,CAAI2J,OAAA,EACR;EAAA;EAEa1E,CAAA,GAA4B,SAAA4E,CACrC7J,CAAA,EACAS,CAAA,EACAE,CAAA;IAEAX,CAAA,CAAIsJ,IAAA,IAEJtJ,CAAA,CAAIuJ,WAAA,GAAc,KAClBvJ,CAAA,CAAIwJ,SAAA,IACJ/I,CAAA,CAAQyI,UAAA,CAAWvI,CAAA,EAAOX,CAAA,GAC1BA,CAAA,CAAI8J,SAAA,GAAY,QAChB9J,CAAA,CAAImI,IAAA,IAEJnI,CAAA,CAAI2J,OAAA,EACR;EAAA;EAEazE,CAAA,GAAsB,SAAA6E,CAC/B/J,CAAA,EAA6BS,CAAA;IAY5B,IAVGE,CAAA,GAAQF,CAAA,CAARuB,QAAA;MACAnB,CAAA,GAAOJ,CAAA,CAAPoB,OAAA;MACAf,CAAA,GAAeL,CAAA,CAAf2C,eAAA;MACApC,CAAA,GAAKP,CAAA,CAALuJ,KAAA;IAQJjF,CAAA,CAAsB/E,CAAA,EAAKa,CAAA,GAEvBC,CAAA,GAAkB,SAClBkE,CAAA,CAA6BhF,CAAA,EAAKW,CAAA,EAAUG,CAAA,GAGlC,SAAVE,CAAA,IACAiE,CAAA,CAA0BjF,CAAA,EAAKa,CAAA,EAASG,CAAA,CAEhD;EAAA;AAAA,SAAA6D,CAAA,IAAAkE,IAAA,EAAAnE,CAAA,IAAAqF,iBAAA,EAAAzF,CAAA,IAAA0F,OAAA,EAAA9I,CAAA,IAAAC,WAAA,EAAAd,CAAA,IAAAC,iBAAA,EAAAxB,CAAA,IAAAmL,mBAAA,EAAAjF,CAAA,IAAA6E,mBAAA,EAAA/E,CAAA,IAAA4E,4BAAA,EAAA3E,CAAA,IAAA4E,yBAAA,EAAA9E,CAAA,IAAAsE,qBAAA,EAAAlF,CAAA,IAAAmD,OAAA,EAAA3E,CAAA,IAAAC,aAAA,EAAA3C,CAAA,IAAAmC,UAAA,EAAAK,CAAA,IAAAC,sBAAA,EAAAT,CAAA,IAAAC,cAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}