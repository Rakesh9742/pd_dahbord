{"ast":null,"code":"import { jsx as t, jsxs as e } from \"react/jsx-runtime\";\nimport { scaleLinear as i } from \"d3-scale\";\nimport { getValueFormatter as n, degreesToRadians as o } from \"@nivo/core\";\nimport { computeContinuousColorScaleColorStops as r } from \"@nivo/colors\";\nimport * as l from \"react\";\nimport { Fragment as a, useState as c, useCallback as s, useMemo as d } from \"react\";\nimport { useTheme as h } from \"@nivo/theming\";\nimport { Text as g, setCanvasFont as m, drawCanvasText as f } from \"@nivo/text\";\nvar v = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"circle\", {\n      r: o / 2,\n      cx: i + o / 2,\n      cy: n + o / 2,\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  u = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                    M\" + o / 2 + \" 0\\n                    L\" + .8 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" \" + o + \"\\n                    L\" + .2 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" 0\\n                \",\n        fill: r,\n        opacity: a,\n        strokeWidth: s,\n        stroke: void 0 === d ? \"transparent\" : d,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  },\n  p = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"rect\", {\n      x: i,\n      y: n,\n      fill: r,\n      opacity: a,\n      strokeWidth: s,\n      stroke: void 0 === d ? \"transparent\" : d,\n      width: o,\n      height: o,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  y = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      s = void 0 === c ? 0 : c,\n      d = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                M\" + o / 2 + \" 0\\n                L\" + o + \" \" + o + \"\\n                L0 \" + o + \"\\n                L\" + o / 2 + \" 0\\n            \",\n        fill: r,\n        opacity: a,\n        strokeWidth: s,\n        stroke: void 0 === d ? \"transparent\" : d,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  };\nfunction b() {\n  return b = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var n in i) ({}).hasOwnProperty.call(i, n) && (t[n] = i[n]);\n    }\n    return t;\n  }, b.apply(null, arguments);\n}\nvar k = {\n    translateX: 0,\n    translateY: 0,\n    padding: 0,\n    itemsSpacing: 0,\n    itemDirection: \"left-to-right\",\n    justify: !1,\n    symbolShape: \"square\",\n    symbolSize: 16,\n    symbolSpacing: 8\n  },\n  x = {\n    length: 200,\n    thickness: 16,\n    direction: \"row\",\n    tickPosition: \"after\",\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: !1,\n    tickFormat: function (t) {\n      return \"\" + t;\n    },\n    titleAlign: \"start\",\n    titleOffset: 4\n  },\n  S = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  },\n  A = function (t) {\n    var e,\n      i = t.direction,\n      n = t.itemsSpacing,\n      o = t.padding,\n      r = t.itemCount,\n      l = t.itemWidth,\n      a = t.itemHeight;\n    if (\"number\" != typeof o && (\"object\" != typeof (e = o) || Array.isArray(e) || null === e)) throw new Error(\"Invalid property padding, must be one of: number, object\");\n    var c = \"number\" == typeof o ? {\n        top: o,\n        right: o,\n        bottom: o,\n        left: o\n      } : b({}, S, o),\n      s = c.left + c.right,\n      d = c.top + c.bottom,\n      h = l + s,\n      g = a + d,\n      m = (r - 1) * n;\n    return \"row\" === i ? h = l * r + m + s : \"column\" === i && (g = a * r + m + d), {\n      width: h,\n      height: g,\n      padding: c\n    };\n  },\n  C = function (t) {\n    var e = t.anchor,\n      i = t.translateX,\n      n = t.translateY,\n      o = t.containerWidth,\n      r = t.containerHeight,\n      l = t.width,\n      a = t.height,\n      c = i,\n      s = n;\n    switch (e) {\n      case \"top\":\n        c += (o - l) / 2;\n        break;\n      case \"top-right\":\n        c += o - l;\n        break;\n      case \"right\":\n        c += o - l, s += (r - a) / 2;\n        break;\n      case \"bottom-right\":\n        c += o - l, s += r - a;\n        break;\n      case \"bottom\":\n        c += (o - l) / 2, s += r - a;\n        break;\n      case \"bottom-left\":\n        s += r - a;\n        break;\n      case \"left\":\n        s += (r - a) / 2;\n        break;\n      case \"center\":\n        c += (o - l) / 2, s += (r - a) / 2;\n    }\n    return {\n      x: c,\n      y: s\n    };\n  },\n  z = function (t) {\n    var e,\n      i,\n      n,\n      o,\n      r,\n      l,\n      a = t.direction,\n      c = t.justify,\n      s = t.symbolSize,\n      d = t.symbolSpacing,\n      h = t.width,\n      g = t.height;\n    switch (a) {\n      case \"left-to-right\":\n        e = 0, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = h, r = \"end\") : (n = s + d, r = \"start\");\n        break;\n      case \"right-to-left\":\n        e = h - s, i = (g - s) / 2, o = g / 2, l = \"central\", c ? (n = 0, r = \"start\") : (n = h - s - d, r = \"end\");\n        break;\n      case \"top-to-bottom\":\n        e = (h - s) / 2, i = 0, n = h / 2, r = \"middle\", c ? (o = g, l = \"alphabetic\") : (o = s + d, l = \"text-before-edge\");\n        break;\n      case \"bottom-to-top\":\n        e = (h - s) / 2, i = g - s, n = h / 2, r = \"middle\", c ? (o = 0, l = \"text-before-edge\") : (o = g - s - d, l = \"alphabetic\");\n    }\n    return {\n      symbolX: e,\n      symbolY: i,\n      labelX: n,\n      labelY: o,\n      labelAnchor: r,\n      labelAlignment: l\n    };\n  },\n  W = function (t) {\n    var e,\n      o = t.scale,\n      l = t.ticks,\n      a = t.length,\n      c = void 0 === a ? x.length : a,\n      s = t.thickness,\n      d = void 0 === s ? x.thickness : s,\n      h = t.direction,\n      g = void 0 === h ? x.direction : h,\n      m = t.tickPosition,\n      f = void 0 === m ? x.tickPosition : m,\n      v = t.tickSize,\n      u = void 0 === v ? x.tickSize : v,\n      p = t.tickSpacing,\n      y = void 0 === p ? x.tickSpacing : p,\n      b = t.tickOverlap,\n      k = void 0 === b ? x.tickOverlap : b,\n      S = t.tickFormat,\n      A = void 0 === S ? x.tickFormat : S,\n      C = t.title,\n      z = t.titleAlign,\n      W = void 0 === z ? x.titleAlign : z,\n      w = t.titleOffset,\n      X = void 0 === w ? x.titleOffset : w,\n      Y = \"column\" === g ? [].concat(o.domain()).reverse() : o.domain(),\n      O = i().domain(Y);\n    2 === Y.length ? O.range([0, c]) : 3 === Y.length && O.range([0, c / 2, c]), e = \"thresholds\" in o ? [Y[0]].concat(o.thresholds(), [Y[1]]) : Array.isArray(l) ? l : o.ticks(l);\n    var B,\n      H,\n      E,\n      j,\n      L,\n      M,\n      P = r(o, 32),\n      F = n(A),\n      T = [],\n      V = 0,\n      D = 0;\n    if (\"row\" === g) {\n      var R, q, G;\n      B = c, H = d, D = 1;\n      var I;\n      L = 0, E = \"start\" === W ? 0 : \"middle\" === W ? c / 2 : c, \"before\" === f ? (R = -u, q = k ? d : 0, G = -u - y, I = \"alphabetic\", j = d + X, M = \"hanging\") : (R = k ? 0 : d, G = (q = d + u) + y, I = \"hanging\", j = -X, M = \"alphabetic\"), e.forEach(function (t) {\n        var e = O(t);\n        T.push({\n          x1: e,\n          y1: R,\n          x2: e,\n          y2: q,\n          text: F(t),\n          textX: e,\n          textY: G,\n          textHorizontalAlign: \"middle\",\n          textVerticalAlign: I\n        });\n      });\n    } else {\n      var _, J, K, N;\n      B = d, H = c, V = 1;\n      L = -90, j = \"start\" === W ? c : \"middle\" === W ? c / 2 : 0, \"before\" === f ? (J = k ? d : 0, K = (_ = -u) - y, N = \"end\", E = d + X, M = \"hanging\") : (_ = k ? 0 : d, K = (J = d + u) + y, N = \"start\", E = -X, M = \"alphabetic\"), e.forEach(function (t) {\n        var e = O(t);\n        T.push({\n          x1: _,\n          y1: e,\n          x2: J,\n          y2: e,\n          text: F(t),\n          textX: K,\n          textY: e,\n          textHorizontalAlign: N,\n          textVerticalAlign: \"central\"\n        });\n      });\n    }\n    return {\n      width: B,\n      height: H,\n      gradientX1: 0,\n      gradientY1: V,\n      gradientX2: D,\n      gradientY2: 0,\n      colorStops: P,\n      ticks: T,\n      titleText: C,\n      titleX: E,\n      titleY: j,\n      titleRotation: L,\n      titleHorizontalAlign: W,\n      titleVerticalAlign: M\n    };\n  },\n  w = function (i) {\n    var n = i.scale,\n      o = i.ticks,\n      r = i.length,\n      l = void 0 === r ? x.length : r,\n      c = i.thickness,\n      s = void 0 === c ? x.thickness : c,\n      d = i.direction,\n      m = void 0 === d ? x.direction : d,\n      f = i.tickPosition,\n      v = void 0 === f ? x.tickPosition : f,\n      u = i.tickSize,\n      p = void 0 === u ? x.tickSize : u,\n      y = i.tickSpacing,\n      b = void 0 === y ? x.tickSpacing : y,\n      k = i.tickOverlap,\n      S = void 0 === k ? x.tickOverlap : k,\n      A = i.tickFormat,\n      C = void 0 === A ? x.tickFormat : A,\n      z = i.title,\n      w = i.titleAlign,\n      X = void 0 === w ? x.titleAlign : w,\n      Y = i.titleOffset,\n      O = W({\n        scale: n,\n        ticks: o,\n        length: l,\n        thickness: s,\n        direction: m,\n        tickPosition: v,\n        tickSize: p,\n        tickSpacing: b,\n        tickOverlap: S,\n        tickFormat: C,\n        title: z,\n        titleAlign: X,\n        titleOffset: void 0 === Y ? x.titleOffset : Y\n      }),\n      B = O.width,\n      H = O.height,\n      E = O.gradientX1,\n      j = O.gradientY1,\n      L = O.gradientX2,\n      M = O.gradientY2,\n      P = O.ticks,\n      F = O.colorStops,\n      T = O.titleText,\n      V = O.titleX,\n      D = O.titleY,\n      R = O.titleRotation,\n      q = O.titleVerticalAlign,\n      G = O.titleHorizontalAlign,\n      I = h(),\n      _ = \"ContinuousColorsLegendSvgGradient.\" + m + \".\" + F.map(function (t) {\n        return t.stopColor.replace(/[(),\\s]/g, \"\") + \".\" + t.offset;\n      }).join(\"_\");\n    return e(\"g\", {\n      children: [t(\"defs\", {\n        children: t(\"linearGradient\", {\n          id: _,\n          x1: E,\n          y1: j,\n          x2: L,\n          y2: M,\n          children: F.map(function (e) {\n            return t(\"stop\", {\n              offset: e.offset,\n              stopColor: e.stopColor\n            }, e.key);\n          })\n        })\n      }), T && t(\"text\", {\n        transform: \"translate(\" + V + \", \" + D + \") rotate(\" + R + \")\",\n        textAnchor: G,\n        dominantBaseline: q,\n        style: I.legends.title.text,\n        children: T\n      }), t(\"rect\", {\n        width: B,\n        height: H,\n        fill: \"url(#\" + _\n      }), P.map(function (i, n) {\n        return e(a, {\n          children: [t(\"line\", {\n            x1: i.x1,\n            y1: i.y1,\n            x2: i.x2,\n            y2: i.y2,\n            style: I.legends.ticks.line\n          }), t(g, {\n            x: i.textX,\n            y: i.textY,\n            textAnchor: i.textHorizontalAlign,\n            dominantBaseline: i.textVerticalAlign,\n            style: I.legends.ticks.text,\n            children: i.text\n          })]\n        }, n);\n      })]\n    });\n  },\n  X = [\"containerWidth\", \"containerHeight\", \"anchor\", \"translateX\", \"translateY\", \"length\", \"thickness\", \"direction\"],\n  Y = function (e) {\n    var i,\n      n,\n      o = e.containerWidth,\n      r = e.containerHeight,\n      l = e.anchor,\n      a = e.translateX,\n      c = void 0 === a ? 0 : a,\n      s = e.translateY,\n      d = void 0 === s ? 0 : s,\n      h = e.length,\n      g = void 0 === h ? x.length : h,\n      m = e.thickness,\n      f = void 0 === m ? x.thickness : m,\n      v = e.direction,\n      u = void 0 === v ? x.direction : v,\n      p = function (t, e) {\n        if (null == t) return {};\n        var i = {};\n        for (var n in t) if ({}.hasOwnProperty.call(t, n)) {\n          if (-1 !== e.indexOf(n)) continue;\n          i[n] = t[n];\n        }\n        return i;\n      }(e, X);\n    \"row\" === u ? (i = g, n = f) : (i = f, n = g);\n    var y = C({\n        anchor: l,\n        translateX: c,\n        translateY: d,\n        containerWidth: o,\n        containerHeight: r,\n        width: i,\n        height: n\n      }),\n      k = y.x,\n      S = y.y;\n    return t(\"g\", {\n      transform: \"translate(\" + k + \", \" + S + \")\",\n      children: t(w, b({\n        length: g,\n        thickness: f,\n        direction: u\n      }, p))\n    });\n  },\n  O = {\n    circle: v,\n    diamond: u,\n    square: p,\n    triangle: y\n  },\n  B = function (i) {\n    var n,\n      o,\n      r,\n      a,\n      d,\n      m,\n      f,\n      v,\n      u,\n      p,\n      y,\n      x = i.x,\n      S = i.y,\n      A = i.width,\n      C = i.height,\n      W = i.data,\n      w = i.direction,\n      X = void 0 === w ? k.itemDirection : w,\n      Y = i.justify,\n      B = void 0 === Y ? k.justify : Y,\n      H = i.textColor,\n      E = i.background,\n      j = void 0 === E ? \"transparent\" : E,\n      L = i.opacity,\n      M = void 0 === L ? 1 : L,\n      P = i.symbolShape,\n      F = void 0 === P ? k.symbolShape : P,\n      T = i.symbolSize,\n      V = void 0 === T ? k.symbolSize : T,\n      D = i.symbolSpacing,\n      R = void 0 === D ? k.symbolSpacing : D,\n      q = i.symbolBorderWidth,\n      G = void 0 === q ? 0 : q,\n      I = i.symbolBorderColor,\n      _ = void 0 === I ? \"transparent\" : I,\n      J = i.onClick,\n      K = i.onMouseEnter,\n      N = i.onMouseLeave,\n      Q = i.toggleSerie,\n      U = i.effects,\n      Z = c({}),\n      $ = Z[0],\n      tt = Z[1],\n      et = h(),\n      it = s(function (t) {\n        if (U) {\n          var e = U.filter(function (t) {\n            return \"hover\" === t.on;\n          }).reduce(function (t, e) {\n            return b({}, t, e.style);\n          }, {});\n          tt(e);\n        }\n        null == K || K(W, t);\n      }, [K, W, U]),\n      nt = s(function (t) {\n        if (U) {\n          var e = U.filter(function (t) {\n            return \"hover\" !== t.on;\n          }).reduce(function (t, e) {\n            return b({}, t, e.style);\n          }, {});\n          tt(e);\n        }\n        null == N || N(W, t);\n      }, [N, W, U]),\n      ot = z({\n        direction: X,\n        justify: B,\n        symbolSize: null != (n = $.symbolSize) ? n : V,\n        symbolSpacing: R,\n        width: A,\n        height: C\n      }),\n      rt = ot.symbolX,\n      lt = ot.symbolY,\n      at = ot.labelX,\n      ct = ot.labelY,\n      st = ot.labelAnchor,\n      dt = ot.labelAlignment,\n      ht = [J, K, N, Q].some(function (t) {\n        return void 0 !== t;\n      }),\n      gt = \"function\" == typeof F ? F : O[F];\n    return e(\"g\", {\n      transform: \"translate(\" + x + \",\" + S + \")\",\n      style: {\n        opacity: null != (o = $.itemOpacity) ? o : M\n      },\n      children: [t(\"rect\", {\n        width: A,\n        height: C,\n        fill: null != (r = $.itemBackground) ? r : j,\n        style: {\n          cursor: ht ? \"pointer\" : \"auto\"\n        },\n        onClick: function (t) {\n          null == J || J(W, t), null == Q || Q(W.id);\n        },\n        onMouseEnter: it,\n        onMouseLeave: nt\n      }), l.createElement(gt, b({\n        id: W.id,\n        x: rt,\n        y: lt,\n        size: null != (a = $.symbolSize) ? a : V,\n        fill: null != (d = null != (m = W.fill) ? m : W.color) ? d : \"black\",\n        borderWidth: null != (f = $.symbolBorderWidth) ? f : G,\n        borderColor: null != (v = $.symbolBorderColor) ? v : _\n      }, W.hidden ? et.legends.hidden.symbol : void 0)), t(g, {\n        textAnchor: st,\n        style: b({}, et.legends.text, {\n          fill: null != (u = null != (p = null != (y = $.itemTextColor) ? y : H) ? p : et.legends.text.fill) ? u : \"black\",\n          dominantBaseline: dt,\n          pointerEvents: \"none\",\n          userSelect: \"none\"\n        }, W.hidden ? et.legends.hidden.text : void 0),\n        x: at,\n        y: ct,\n        children: W.label\n      })]\n    });\n  },\n  H = function (e) {\n    var i = e.data,\n      n = e.x,\n      o = e.y,\n      r = e.direction,\n      l = e.padding,\n      a = void 0 === l ? k.padding : l,\n      c = e.justify,\n      s = e.effects,\n      d = e.itemWidth,\n      h = e.itemHeight,\n      g = e.itemDirection,\n      m = void 0 === g ? k.itemDirection : g,\n      f = e.itemsSpacing,\n      v = void 0 === f ? k.itemsSpacing : f,\n      u = e.itemTextColor,\n      p = e.itemBackground,\n      y = void 0 === p ? \"transparent\" : p,\n      b = e.itemOpacity,\n      x = void 0 === b ? 1 : b,\n      S = e.symbolShape,\n      C = e.symbolSize,\n      z = e.symbolSpacing,\n      W = e.symbolBorderWidth,\n      w = e.symbolBorderColor,\n      X = e.onClick,\n      Y = e.onMouseEnter,\n      O = e.onMouseLeave,\n      H = e.toggleSerie,\n      E = A({\n        itemCount: i.length,\n        itemWidth: d,\n        itemHeight: h,\n        itemsSpacing: v,\n        direction: r,\n        padding: a\n      }).padding,\n      j = \"row\" === r ? d + v : 0,\n      L = \"column\" === r ? h + v : 0;\n    return t(\"g\", {\n      transform: \"translate(\" + n + \",\" + o + \")\",\n      children: i.map(function (e, i) {\n        return t(B, {\n          data: e,\n          x: i * j + E.left,\n          y: i * L + E.top,\n          width: d,\n          height: h,\n          direction: m,\n          justify: c,\n          effects: s,\n          textColor: u,\n          background: y,\n          opacity: x,\n          symbolShape: S,\n          symbolSize: C,\n          symbolSpacing: z,\n          symbolBorderWidth: W,\n          symbolBorderColor: w,\n          onClick: X,\n          onMouseEnter: Y,\n          onMouseLeave: O,\n          toggleSerie: H\n        }, i);\n      })\n    });\n  },\n  E = function (e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? k.translateX : r,\n      a = e.translateY,\n      c = void 0 === a ? k.translateY : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? k.padding : h,\n      m = e.justify,\n      f = e.itemsSpacing,\n      v = void 0 === f ? k.itemsSpacing : f,\n      u = e.itemWidth,\n      p = e.itemHeight,\n      y = e.itemDirection,\n      b = e.itemTextColor,\n      x = e.itemBackground,\n      S = e.itemOpacity,\n      z = e.symbolShape,\n      W = e.symbolSize,\n      w = e.symbolSpacing,\n      X = e.symbolBorderWidth,\n      Y = e.symbolBorderColor,\n      O = e.onClick,\n      B = e.onMouseEnter,\n      E = e.onMouseLeave,\n      j = e.toggleSerie,\n      L = e.effects,\n      M = A({\n        itemCount: i.length,\n        itemsSpacing: v,\n        itemWidth: u,\n        itemHeight: p,\n        direction: d,\n        padding: g\n      }),\n      P = M.width,\n      F = M.height,\n      T = C({\n        anchor: s,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: P,\n        height: F\n      }),\n      V = T.x,\n      D = T.y;\n    return t(H, {\n      data: i,\n      x: V,\n      y: D,\n      direction: d,\n      padding: g,\n      justify: m,\n      effects: L,\n      itemsSpacing: v,\n      itemWidth: u,\n      itemHeight: p,\n      itemDirection: y,\n      itemTextColor: b,\n      itemBackground: x,\n      itemOpacity: S,\n      symbolShape: z,\n      symbolSize: W,\n      symbolSpacing: w,\n      symbolBorderWidth: X,\n      symbolBorderColor: Y,\n      onClick: O,\n      onMouseEnter: B,\n      onMouseLeave: E,\n      toggleSerie: \"boolean\" == typeof j ? void 0 : j\n    });\n  },\n  j = {\n    start: \"left\",\n    middle: \"center\",\n    end: \"right\"\n  },\n  L = function (t, e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      s = e.anchor,\n      d = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      v = e.justify,\n      u = void 0 !== v && v,\n      p = e.itemsSpacing,\n      y = void 0 === p ? 0 : p,\n      k = e.itemWidth,\n      x = e.itemHeight,\n      S = e.itemDirection,\n      W = void 0 === S ? \"left-to-right\" : S,\n      w = e.itemTextColor,\n      X = e.symbolSize,\n      Y = void 0 === X ? 16 : X,\n      O = e.symbolSpacing,\n      B = void 0 === O ? 8 : O,\n      H = e.theme,\n      E = A({\n        itemCount: i.length,\n        itemWidth: k,\n        itemHeight: x,\n        itemsSpacing: y,\n        direction: d,\n        padding: g\n      }),\n      L = E.width,\n      M = E.height,\n      P = E.padding,\n      F = C({\n        anchor: s,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: L,\n        height: M\n      }),\n      T = F.x,\n      V = F.y,\n      D = \"row\" === d ? k + y : 0,\n      R = \"column\" === d ? x + y : 0;\n    t.save(), t.translate(T, V), m(t, H.legends.text), i.forEach(function (e, i) {\n      var n,\n        o = i * D + P.left,\n        r = i * R + P.top,\n        l = z({\n          direction: W,\n          justify: u,\n          symbolSize: Y,\n          symbolSpacing: B,\n          width: k,\n          height: x\n        }),\n        a = l.symbolX,\n        c = l.symbolY,\n        s = l.labelX,\n        d = l.labelY,\n        h = l.labelAnchor,\n        g = l.labelAlignment;\n      t.fillStyle = null != (n = e.color) ? n : \"black\", t.fillRect(o + a, r + c, Y, Y), t.textAlign = j[h], \"central\" === g && (t.textBaseline = \"middle\"), f(t, b({}, H.legends.text, {\n        fill: null != w ? w : H.legends.text.fill\n      }), String(e.label), o + s, r + d);\n    }), t.restore();\n  },\n  M = function (t, e) {\n    var i,\n      n = e.containerWidth,\n      r = e.containerHeight,\n      l = e.anchor,\n      a = e.translateX,\n      c = void 0 === a ? 0 : a,\n      s = e.translateY,\n      d = void 0 === s ? 0 : s,\n      h = e.scale,\n      g = e.length,\n      v = void 0 === g ? x.length : g,\n      u = e.thickness,\n      p = void 0 === u ? x.thickness : u,\n      y = e.direction,\n      b = void 0 === y ? x.direction : y,\n      k = e.ticks,\n      S = e.tickPosition,\n      A = void 0 === S ? x.tickPosition : S,\n      z = e.tickSize,\n      w = void 0 === z ? x.tickSize : z,\n      X = e.tickSpacing,\n      Y = void 0 === X ? x.tickSpacing : X,\n      O = e.tickOverlap,\n      B = void 0 === O ? x.tickOverlap : O,\n      H = e.tickFormat,\n      E = void 0 === H ? x.tickFormat : H,\n      j = e.title,\n      L = e.titleAlign,\n      M = void 0 === L ? x.titleAlign : L,\n      P = e.titleOffset,\n      F = void 0 === P ? x.titleOffset : P,\n      T = e.theme,\n      V = W({\n        scale: h,\n        ticks: k,\n        length: v,\n        thickness: p,\n        direction: b,\n        tickPosition: A,\n        tickSize: w,\n        tickSpacing: Y,\n        tickOverlap: B,\n        tickFormat: E,\n        title: j,\n        titleAlign: M,\n        titleOffset: F\n      }),\n      D = V.width,\n      R = V.height,\n      q = V.gradientX1,\n      G = V.gradientY1,\n      I = V.gradientX2,\n      _ = V.gradientY2,\n      J = V.colorStops,\n      K = V.ticks,\n      N = V.titleText,\n      Q = V.titleX,\n      U = V.titleY,\n      Z = V.titleRotation,\n      $ = V.titleVerticalAlign,\n      tt = V.titleHorizontalAlign,\n      et = C({\n        anchor: l,\n        translateX: c,\n        translateY: d,\n        containerWidth: n,\n        containerHeight: r,\n        width: D,\n        height: R\n      }),\n      it = et.x,\n      nt = et.y,\n      ot = {\n        font: t.font,\n        textAlign: t.textAlign,\n        textBaseline: t.textBaseline\n      };\n    t.save(), t.translate(it, nt);\n    var rt = t.createLinearGradient(q * D, G * R, I * D, _ * R);\n    J.forEach(function (t) {\n      rt.addColorStop(t.offset, t.stopColor);\n    }), t.fillStyle = rt, t.fillRect(0, 0, D, R), m(t, T.legends.ticks.text);\n    var lt = null != (i = T.legends.ticks.line.strokeWidth) ? i : 0,\n      at = \"string\" != typeof lt && lt > 0;\n    K.forEach(function (e) {\n      at && (t.lineWidth = lt, T.axis.ticks.line.stroke && (t.strokeStyle = T.axis.ticks.line.stroke), t.lineCap = \"square\", t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke()), t.textAlign = \"middle\" === e.textHorizontalAlign ? \"center\" : e.textHorizontalAlign, t.textBaseline = \"central\" === e.textVerticalAlign ? \"middle\" : e.textVerticalAlign, f(t, T.legends.ticks.text, e.text, e.textX, e.textY);\n    }), N && (t.save(), t.translate(Q, U), t.rotate(o(Z)), m(t, T.legends.title.text), t.textAlign = \"middle\" === tt ? \"center\" : tt, t.textBaseline = $, f(t, T.legends.title.text, N), t.restore()), t.restore(), t.font = ot.font, t.textAlign = ot.textAlign, t.textBaseline = ot.textBaseline;\n  },\n  P = function (t) {\n    var e = t.scale,\n      i = t.domain,\n      n = t.reverse,\n      o = void 0 !== n && n,\n      r = t.valueFormat,\n      l = void 0 === r ? function (t) {\n        return t;\n      } : r,\n      a = t.separator,\n      c = void 0 === a ? \" - \" : a;\n    return d(function () {\n      var t = (null != i ? i : e.range()).map(function (t, i) {\n        var n = e.invertExtent(t),\n          o = n[0],\n          r = n[1];\n        return {\n          id: t,\n          index: i,\n          extent: [o, r],\n          label: \"\" + l(o) + c + l(r),\n          value: e(o),\n          color: t\n        };\n      });\n      return o && t.reverse(), t;\n    }, [i, e, o, c, l]);\n  };\nexport { Y as AnchoredContinuousColorsLegendSvg, E as BoxLegendSvg, w as ContinuousColorsLegendSvg, H as LegendSvg, B as LegendSvgItem, v as SymbolCircle, u as SymbolDiamond, p as SymbolSquare, y as SymbolTriangle, W as computeContinuousColorsLegend, A as computeDimensions, z as computeItemLayout, C as computePositionFromAnchor, x as continuousColorsLegendDefaults, k as legendDefaults, M as renderContinuousColorLegendToCanvas, L as renderLegendToCanvas, P as useQuantizeColorScaleLegendData };","map":{"version":3,"names":["v","SymbolCircle","e","i","x","n","y","o","size","r","fill","l","opacity","a","c","borderWidth","s","d","borderColor","t","cx","cy","strokeWidth","stroke","style","pointerEvents","u","SymbolDiamond","transform","children","p","SymbolSquare","width","height","SymbolTriangle","b","Object","assign","bind","arguments","length","hasOwnProperty","call","apply","k","translateX","translateY","padding","itemsSpacing","itemDirection","justify","symbolShape","symbolSize","symbolSpacing","thickness","direction","tickPosition","tickSize","tickSpacing","tickOverlap","tickFormat","titleAlign","titleOffset","S","top","right","bottom","left","A","computeDimensions","itemCount","itemWidth","itemHeight","Array","isArray","Error","h","g","m","C","computePositionFromAnchor","anchor","containerWidth","containerHeight","z","computeItemLayout","symbolX","symbolY","labelX","labelY","labelAnchor","labelAlignment","W","computeContinuousColorsLegend","scale","ticks","f","title","w","X","Y","concat","domain","reverse","O","range","thresholds","B","H","E","j","L","M","P","F","T","V","D","R","q","G","I","forEach","push","x1","y1","x2","y2","text","textX","textY","textHorizontalAlign","textVerticalAlign","_","J","K","N","gradientX1","gradientY1","gradientX2","gradientY2","colorStops","titleText","titleX","titleY","titleRotation","titleHorizontalAlign","titleVerticalAlign","ContinuousColorsLegendSvg","map","stopColor","replace","offset","join","id","key","textAnchor","dominantBaseline","legends","line","AnchoredContinuousColorsLegendSvg","indexOf","circle","diamond","square","triangle","LegendSvgItem","data","textColor","background","symbolBorderWidth","symbolBorderColor","onClick","onMouseEnter","onMouseLeave","Q","toggleSerie","U","effects","Z","$","tt","et","it","filter","on","reduce","nt","ot","rt","lt","at","ct","st","dt","ht","some","gt","itemOpacity","itemBackground","cursor","createElement","color","hidden","symbol","itemTextColor","userSelect","label","LegendSvg","BoxLegendSvg","start","middle","end","renderLegendToCanvas","theme","save","translate","fillStyle","fillRect","textAlign","textBaseline","String","restore","renderContinuousColorLegendToCanvas","font","createLinearGradient","addColorStop","lineWidth","axis","strokeStyle","lineCap","beginPath","moveTo","lineTo","rotate","useQuantizeColorScaleLegendData","valueFormat","separator","invertExtent","index","extent","value","continuousColorsLegendDefaults","legendDefaults"],"sources":["C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolCircle.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolDiamond.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolSquare.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\symbols\\SymbolTriangle.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\defaults.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\compute.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\ContinuousColorsLegendSvg.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\AnchoredContinuousColorsLegendSvg.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\LegendSvgItem.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\LegendSvg.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\svg\\BoxLegendSvg.tsx","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\canvas.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\legends\\src\\hooks.ts"],"sourcesContent":["import { SymbolProps } from './types'\n\nexport const SymbolCircle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <circle\n            r={size / 2}\n            cx={x + size / 2}\n            cy={y + size / 2}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolDiamond = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                    M${size / 2} 0\n                    L${size * 0.8} ${size / 2}\n                    L${size / 2} ${size}\n                    L${size * 0.2} ${size / 2}\n                    L${size / 2} 0\n                `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolSquare = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <rect\n            x={x}\n            y={y}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            width={size}\n            height={size}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolTriangle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                M${size / 2} 0\n                L${size} ${size}\n                L0 ${size}\n                L${size / 2} 0\n            `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { BoxLegendSvgProps, ContinuousColorsLegendProps } from './types'\n\nexport const legendDefaults: {\n    translateX: NonNullable<BoxLegendSvgProps['translateX']>\n    translateY: NonNullable<BoxLegendSvgProps['translateY']>\n    padding: NonNullable<BoxLegendSvgProps['padding']>\n    itemsSpacing: NonNullable<BoxLegendSvgProps['itemsSpacing']>\n    itemDirection: NonNullable<BoxLegendSvgProps['itemDirection']>\n    justify: NonNullable<BoxLegendSvgProps['justify']>\n    symbolShape: NonNullable<BoxLegendSvgProps['symbolShape']>\n    symbolSize: NonNullable<BoxLegendSvgProps['symbolSize']>\n    symbolSpacing: NonNullable<BoxLegendSvgProps['symbolSpacing']>\n} = {\n    translateX: 0,\n    translateY: 0,\n    padding: 0,\n    itemsSpacing: 0,\n    itemDirection: 'left-to-right',\n    justify: false,\n    symbolShape: 'square',\n    symbolSize: 16,\n    symbolSpacing: 8,\n}\n\nexport const continuousColorsLegendDefaults: {\n    length: NonNullable<ContinuousColorsLegendProps['length']>\n    thickness: NonNullable<ContinuousColorsLegendProps['thickness']>\n    direction: NonNullable<ContinuousColorsLegendProps['direction']>\n    tickPosition: NonNullable<ContinuousColorsLegendProps['tickPosition']>\n    tickSize: NonNullable<ContinuousColorsLegendProps['tickSize']>\n    tickSpacing: NonNullable<ContinuousColorsLegendProps['tickSpacing']>\n    tickOverlap: NonNullable<ContinuousColorsLegendProps['tickOverlap']>\n    tickFormat: NonNullable<ContinuousColorsLegendProps['tickFormat']>\n    titleAlign: NonNullable<ContinuousColorsLegendProps['titleAlign']>\n    titleOffset: NonNullable<ContinuousColorsLegendProps['titleOffset']>\n} = {\n    length: 200,\n    thickness: 16,\n    direction: 'row',\n    tickPosition: 'after',\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: false,\n    tickFormat: (value: number) => `${value}`,\n    titleAlign: 'start',\n    titleOffset: 4,\n}\n","import { scaleLinear } from 'd3-scale'\nimport { getValueFormatter } from '@nivo/core'\nimport { computeContinuousColorScaleColorStops } from '@nivo/colors'\nimport {\n    BoxLegendSvgProps,\n    ContinuousColorsLegendProps,\n    LegendAnchor,\n    LegendItemDirection,\n} from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst isObject = <T>(item: unknown): item is T =>\n    typeof item === 'object' && !Array.isArray(item) && item !== null\n\nconst zeroPadding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n}\n\nexport const computeDimensions = ({\n    direction,\n    itemsSpacing,\n    padding: _padding,\n    itemCount,\n    itemWidth,\n    itemHeight,\n}: Pick<BoxLegendSvgProps, 'direction' | 'padding'> &\n    Record<'itemsSpacing' | 'itemCount' | 'itemWidth' | 'itemHeight', number>) => {\n    if (typeof _padding !== 'number' && !isObject(_padding)) {\n        throw new Error('Invalid property padding, must be one of: number, object')\n    }\n\n    const padding =\n        typeof _padding === 'number'\n            ? {\n                  top: _padding,\n                  right: _padding,\n                  bottom: _padding,\n                  left: _padding,\n              }\n            : {\n                  ...zeroPadding,\n                  ..._padding,\n              }\n\n    const horizontalPadding = padding.left + padding.right\n    const verticalPadding = padding.top + padding.bottom\n    let width = itemWidth + horizontalPadding\n    let height = itemHeight + verticalPadding\n    const spacing = (itemCount - 1) * itemsSpacing\n    if (direction === 'row') {\n        width = itemWidth * itemCount + spacing + horizontalPadding\n    } else if (direction === 'column') {\n        height = itemHeight * itemCount + spacing + verticalPadding\n    }\n\n    return { width, height, padding }\n}\n\nexport const computePositionFromAnchor = ({\n    anchor,\n    translateX,\n    translateY,\n    containerWidth,\n    containerHeight,\n    width,\n    height,\n}: { anchor: LegendAnchor } & Record<\n    'translateX' | 'translateY' | 'containerWidth' | 'containerHeight' | 'width' | 'height',\n    number\n>) => {\n    let x = translateX\n    let y = translateY\n\n    switch (anchor) {\n        case 'top':\n            x += (containerWidth - width) / 2\n            break\n\n        case 'top-right':\n            x += containerWidth - width\n            break\n\n        case 'right':\n            x += containerWidth - width\n            y += (containerHeight - height) / 2\n            break\n\n        case 'bottom-right':\n            x += containerWidth - width\n            y += containerHeight - height\n            break\n\n        case 'bottom':\n            x += (containerWidth - width) / 2\n            y += containerHeight - height\n            break\n\n        case 'bottom-left':\n            y += containerHeight - height\n            break\n\n        case 'left':\n            y += (containerHeight - height) / 2\n            break\n\n        case 'center':\n            x += (containerWidth - width) / 2\n            y += (containerHeight - height) / 2\n            break\n    }\n\n    return { x, y }\n}\n\nexport const computeItemLayout = ({\n    direction,\n    justify,\n    symbolSize,\n    symbolSpacing,\n    width,\n    height,\n}: {\n    direction: LegendItemDirection\n    justify: boolean\n} & Record<'symbolSize' | 'symbolSpacing' | 'width' | 'height', number>) => {\n    let symbolX\n    let symbolY\n\n    let labelX\n    let labelY\n    let labelAnchor: 'start' | 'middle' | 'end'\n    let labelAlignment: 'alphabetic' | 'central' | 'text-before-edge'\n\n    switch (direction) {\n        case 'left-to-right':\n            symbolX = 0\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = width\n                labelAnchor = 'end'\n            } else {\n                labelX = symbolSize + symbolSpacing\n                labelAnchor = 'start'\n            }\n            break\n\n        case 'right-to-left':\n            symbolX = width - symbolSize\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = 0\n                labelAnchor = 'start'\n            } else {\n                labelX = width - symbolSize - symbolSpacing\n                labelAnchor = 'end'\n            }\n            break\n\n        case 'top-to-bottom':\n            symbolX = (width - symbolSize) / 2\n            symbolY = 0\n\n            labelX = width / 2\n\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = height\n                labelAlignment = 'alphabetic'\n            } else {\n                labelY = symbolSize + symbolSpacing\n                labelAlignment = 'text-before-edge'\n            }\n            break\n\n        case 'bottom-to-top':\n            symbolX = (width - symbolSize) / 2\n            symbolY = height - symbolSize\n\n            labelX = width / 2\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = 0\n                labelAlignment = 'text-before-edge'\n            } else {\n                labelY = height - symbolSize - symbolSpacing\n                labelAlignment = 'alphabetic'\n            }\n            break\n    }\n\n    return {\n        symbolX,\n        symbolY,\n        labelX,\n        labelY,\n        labelAnchor,\n        labelAlignment,\n    }\n}\n\nexport const computeContinuousColorsLegend = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    // left to right for `row`, bottom to top for `column`\n    const domain = direction === 'column' ? [...scale.domain()].reverse() : scale.domain()\n\n    const positionScale = scaleLinear().domain(domain)\n    if (domain.length === 2) {\n        // sequential, quantize\n        positionScale.range([0, length])\n    } else if (domain.length === 3) {\n        // diverging\n        positionScale.range([0, length / 2, length])\n    }\n\n    let values: number[]\n    if ('thresholds' in scale) {\n        // quantize\n        values = [domain[0], ...scale.thresholds(), domain[1]]\n    } else {\n        // sequential, diverging\n        values = Array.isArray(ticks) ? ticks : (scale as any).ticks(ticks)\n    }\n\n    const colorStops = computeContinuousColorScaleColorStops(scale, 32)\n\n    const formatValue = getValueFormatter(tickFormat)\n\n    const computedTicks: {\n        x1: number\n        y1: number\n        x2: number\n        y2: number\n        text: string\n        textX: number\n        textY: number\n        textHorizontalAlign: 'start' | 'middle' | 'end'\n        textVerticalAlign: 'alphabetic' | 'central' | 'hanging'\n    }[] = []\n\n    let width: number\n    let height: number\n\n    const gradientX1 = 0\n    let gradientY1 = 0\n    let gradientX2 = 0\n    const gradientY2 = 0\n\n    let titleX: number\n    let titleY: number\n    let titleRotation: number\n    let titleVerticalAlign: 'alphabetic' | 'hanging'\n\n    if (direction === 'row') {\n        width = length\n        height = thickness\n\n        gradientX2 = 1\n\n        let y1: number\n        let y2: number\n\n        let textY: number\n        const textHorizontalAlign = 'middle'\n        let textVerticalAlign: 'alphabetic' | 'hanging'\n\n        titleRotation = 0\n        if (titleAlign === 'start') {\n            titleX = 0\n        } else if (titleAlign === 'middle') {\n            titleX = length / 2\n        } else {\n            titleX = length\n        }\n\n        if (tickPosition === 'before') {\n            y1 = -tickSize\n            y2 = tickOverlap ? thickness : 0\n\n            textY = -tickSize - tickSpacing\n            textVerticalAlign = 'alphabetic'\n\n            titleY = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            y1 = tickOverlap ? 0 : thickness\n            y2 = thickness + tickSize\n\n            textY = y2 + tickSpacing\n            textVerticalAlign = 'hanging'\n\n            titleY = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const x = positionScale(value)\n\n            computedTicks.push({\n                x1: x,\n                y1,\n                x2: x,\n                y2,\n                text: formatValue(value),\n                textX: x,\n                textY,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    } else {\n        width = thickness\n        height = length\n\n        gradientY1 = 1\n\n        let x1: number\n        let x2: number\n\n        let textX: number\n        let textHorizontalAlign: 'start' | 'end'\n        const textVerticalAlign = 'central'\n\n        titleRotation = -90\n        if (titleAlign === 'start') {\n            titleY = length\n        } else if (titleAlign === 'middle') {\n            titleY = length / 2\n        } else {\n            titleY = 0\n        }\n\n        if (tickPosition === 'before') {\n            x1 = -tickSize\n            x2 = tickOverlap ? thickness : 0\n\n            textX = x1 - tickSpacing\n            textHorizontalAlign = 'end'\n\n            titleX = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            x1 = tickOverlap ? 0 : thickness\n            x2 = thickness + tickSize\n\n            textX = x2 + tickSpacing\n            textHorizontalAlign = 'start'\n\n            titleX = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const y = positionScale(value)\n\n            computedTicks.push({\n                x1,\n                y1: y,\n                x2,\n                y2: y,\n                text: formatValue(value),\n                textX,\n                textY: y,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    }\n\n    return {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks: computedTicks,\n        titleText: title,\n        titleX,\n        titleY,\n        titleRotation,\n        titleHorizontalAlign: titleAlign,\n        titleVerticalAlign,\n    }\n}\n","import { Fragment } from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Text } from '@nivo/text'\nimport { computeContinuousColorsLegend } from '../compute'\nimport { ContinuousColorsLegendProps } from '../types'\nimport { continuousColorsLegendDefaults } from '../defaults'\n\nexport const ContinuousColorsLegendSvg = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        ticks: computedTicks,\n        colorStops,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const theme = useTheme()\n\n    // remove commas, parentheses and spaces from stop color, this will then create a unique id depending on which color scheme you use.\n    // so if you have two or more heatmaps on a single page with differing color schemes the legend will be correct for each.\n    const id = `ContinuousColorsLegendSvgGradient.${direction}.${colorStops\n        .map(stop => `${stop.stopColor.replace(/[(),\\s]/g, '')}.${stop.offset}`)\n        .join('_')}`\n\n    return (\n        <g>\n            <defs>\n                <linearGradient\n                    id={id}\n                    x1={gradientX1}\n                    y1={gradientY1}\n                    x2={gradientX2}\n                    y2={gradientY2}\n                >\n                    {colorStops.map(colorStop => (\n                        <stop\n                            key={colorStop.key}\n                            offset={colorStop.offset}\n                            stopColor={colorStop.stopColor}\n                        />\n                    ))}\n                </linearGradient>\n            </defs>\n            {titleText && (\n                <text\n                    transform={`translate(${titleX}, ${titleY}) rotate(${titleRotation})`}\n                    textAnchor={titleHorizontalAlign}\n                    dominantBaseline={titleVerticalAlign}\n                    style={theme.legends.title.text}\n                >\n                    {titleText}\n                </text>\n            )}\n            <rect width={width} height={height} fill={`url(#${id}`} />\n            {computedTicks.map((tick, index) => (\n                <Fragment key={index}>\n                    <line\n                        x1={tick.x1}\n                        y1={tick.y1}\n                        x2={tick.x2}\n                        y2={tick.y2}\n                        style={theme.legends.ticks.line}\n                    />\n                    <Text\n                        x={tick.textX}\n                        y={tick.textY}\n                        textAnchor={tick.textHorizontalAlign}\n                        dominantBaseline={tick.textVerticalAlign}\n                        style={theme.legends.ticks.text}\n                    >\n                        {tick.text}\n                    </Text>\n                </Fragment>\n            ))}\n        </g>\n    )\n}\n","import { AnchoredContinuousColorsLegendProps } from '../types'\nimport { computePositionFromAnchor } from '../compute'\nimport { continuousColorsLegendDefaults } from '../defaults'\nimport { ContinuousColorsLegendSvg } from './ContinuousColorsLegendSvg'\n\nexport const AnchoredContinuousColorsLegendSvg = ({\n    containerWidth,\n    containerHeight,\n    anchor,\n    translateX = 0,\n    translateY = 0,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    ...legendProps\n}: AnchoredContinuousColorsLegendProps) => {\n    let width: number\n    let height: number\n    if (direction === 'row') {\n        width = length\n        height = thickness\n    } else {\n        width = thickness\n        height = length\n    }\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <g transform={`translate(${x}, ${y})`}>\n            <ContinuousColorsLegendSvg\n                length={length}\n                thickness={thickness}\n                direction={direction}\n                {...legendProps}\n            />\n        </g>\n    )\n}\n","import { useState, useCallback } from 'react'\nimport * as React from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Text } from '@nivo/text'\nimport { LegendSvgItemProps } from '../types'\nimport { legendDefaults } from '../defaults'\nimport { computeItemLayout } from '../compute'\nimport { SymbolCircle, SymbolDiamond, SymbolSquare, SymbolTriangle } from './symbols'\n\ntype Style = Partial<{\n    itemBackground: string\n    itemOpacity: number\n    itemTextColor: string\n    symbolBorderColor: string\n    symbolBorderWidth: number\n    symbolSize: number\n}>\n\nconst symbolByShape = {\n    circle: SymbolCircle,\n    diamond: SymbolDiamond,\n    square: SymbolSquare,\n    triangle: SymbolTriangle,\n}\n\nexport const LegendSvgItem = ({\n    x,\n    y,\n    width,\n    height,\n    data,\n    direction = legendDefaults.itemDirection,\n    justify = legendDefaults.justify,\n    textColor,\n    background = 'transparent',\n    opacity = 1,\n    symbolShape = legendDefaults.symbolShape,\n    symbolSize = legendDefaults.symbolSize,\n    symbolSpacing = legendDefaults.symbolSpacing,\n    symbolBorderWidth = 0,\n    symbolBorderColor = 'transparent',\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n    effects,\n}: LegendSvgItemProps) => {\n    const [style, setStyle] = useState<Style>({})\n    const theme = useTheme()\n\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on === 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseEnter?.(data, event)\n        },\n        [onMouseEnter, data, effects]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on !== 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseLeave?.(data, event)\n        },\n        [onMouseLeave, data, effects]\n    )\n\n    const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout({\n        direction,\n        justify,\n        symbolSize: style.symbolSize ?? symbolSize,\n        symbolSpacing,\n        width,\n        height,\n    })\n\n    const isInteractive = [onClick, onMouseEnter, onMouseLeave, toggleSerie].some(\n        handler => handler !== undefined\n    )\n\n    const SymbolShape = typeof symbolShape === 'function' ? symbolShape : symbolByShape[symbolShape]\n\n    return (\n        <g\n            transform={`translate(${x},${y})`}\n            style={{\n                opacity: style.itemOpacity ?? opacity,\n            }}\n        >\n            <rect\n                width={width}\n                height={height}\n                fill={style.itemBackground ?? background}\n                style={{\n                    cursor: isInteractive ? 'pointer' : 'auto',\n                }}\n                onClick={event => {\n                    onClick?.(data, event)\n                    toggleSerie?.(data.id)\n                }}\n                onMouseEnter={handleMouseEnter}\n                onMouseLeave={handleMouseLeave}\n            />\n            {React.createElement(SymbolShape, {\n                id: data.id,\n                x: symbolX,\n                y: symbolY,\n                size: style.symbolSize ?? symbolSize,\n                fill: data.fill ?? data.color ?? 'black',\n                borderWidth: style.symbolBorderWidth ?? symbolBorderWidth,\n                borderColor: style.symbolBorderColor ?? symbolBorderColor,\n                ...(data.hidden ? theme.legends.hidden.symbol : undefined),\n            })}\n            <Text\n                textAnchor={labelAnchor}\n                style={{\n                    ...theme.legends.text,\n                    fill: style.itemTextColor ?? textColor ?? theme.legends.text.fill ?? 'black',\n                    dominantBaseline: labelAlignment,\n                    pointerEvents: 'none',\n                    userSelect: 'none',\n                    ...(data.hidden ? theme.legends.hidden.text : undefined),\n                }}\n                x={labelX}\n                y={labelY}\n            >\n                {data.label}\n            </Text>\n        </g>\n    )\n}\n","import { LegendSvgItem } from './LegendSvgItem'\nimport { LegendSvgProps } from '../types'\nimport { legendDefaults } from '../defaults'\nimport { computeDimensions } from '../compute'\n\nexport const LegendSvg = ({\n    data,\n    x,\n    y,\n    direction,\n    padding: _padding = legendDefaults.padding,\n    justify,\n    effects,\n    itemWidth,\n    itemHeight,\n    itemDirection = legendDefaults.itemDirection,\n    itemsSpacing = legendDefaults.itemsSpacing,\n    itemTextColor,\n    itemBackground = 'transparent',\n    itemOpacity = 1,\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n}: LegendSvgProps) => {\n    const { padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    return (\n        <g transform={`translate(${x},${y})`}>\n            {data.map((data, i) => (\n                <LegendSvgItem\n                    key={i}\n                    data={data}\n                    x={i * xStep + padding.left}\n                    y={i * yStep + padding.top}\n                    width={itemWidth}\n                    height={itemHeight}\n                    direction={itemDirection}\n                    justify={justify}\n                    effects={effects}\n                    textColor={itemTextColor}\n                    background={itemBackground}\n                    opacity={itemOpacity}\n                    symbolShape={symbolShape}\n                    symbolSize={symbolSize}\n                    symbolSpacing={symbolSpacing}\n                    symbolBorderWidth={symbolBorderWidth}\n                    symbolBorderColor={symbolBorderColor}\n                    onClick={onClick}\n                    onMouseEnter={onMouseEnter}\n                    onMouseLeave={onMouseLeave}\n                    toggleSerie={toggleSerie}\n                />\n            ))}\n        </g>\n    )\n}\n","import { LegendSvg } from './LegendSvg'\nimport { BoxLegendSvgProps } from '../types'\nimport { legendDefaults } from '../defaults'\nimport { computeDimensions, computePositionFromAnchor } from '../compute'\n\nexport const BoxLegendSvg = ({\n    data,\n    containerWidth,\n    containerHeight,\n    translateX = legendDefaults.translateX,\n    translateY = legendDefaults.translateY,\n    anchor,\n    direction,\n    padding = legendDefaults.padding,\n    justify,\n    itemsSpacing = legendDefaults.itemsSpacing,\n    itemWidth,\n    itemHeight,\n    itemDirection,\n    itemTextColor,\n    itemBackground,\n    itemOpacity,\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n    effects,\n}: BoxLegendSvgProps) => {\n    const { width, height } = computeDimensions({\n        itemCount: data.length,\n        itemsSpacing,\n        itemWidth,\n        itemHeight,\n        direction,\n        padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <LegendSvg\n            data={data}\n            x={x}\n            y={y}\n            direction={direction}\n            padding={padding}\n            justify={justify}\n            effects={effects}\n            itemsSpacing={itemsSpacing}\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            itemDirection={itemDirection}\n            itemTextColor={itemTextColor}\n            itemBackground={itemBackground}\n            itemOpacity={itemOpacity}\n            symbolShape={symbolShape}\n            symbolSize={symbolSize}\n            symbolSpacing={symbolSpacing}\n            symbolBorderWidth={symbolBorderWidth}\n            symbolBorderColor={symbolBorderColor}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            toggleSerie={typeof toggleSerie === 'boolean' ? undefined : toggleSerie}\n        />\n    )\n}\n","import { degreesToRadians } from '@nivo/core'\nimport { Theme } from '@nivo/theming'\nimport { setCanvasFont, drawCanvasText } from '@nivo/text'\nimport {\n    computeDimensions,\n    computePositionFromAnchor,\n    computeItemLayout,\n    computeContinuousColorsLegend,\n} from './compute'\nimport { AnchoredContinuousColorsLegendProps, LegendCanvasProps } from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst textAlignMapping = {\n    start: 'left',\n    middle: 'center',\n    end: 'right',\n} as const\n\nexport const renderLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        data,\n\n        containerWidth,\n        containerHeight,\n        translateX = 0,\n        translateY = 0,\n        anchor,\n        direction,\n        padding: _padding = 0,\n        justify = false,\n\n        // items\n        itemsSpacing = 0,\n        itemWidth,\n        itemHeight,\n        itemDirection = 'left-to-right',\n        itemTextColor,\n\n        // symbol\n        symbolSize = 16,\n        symbolSpacing = 8,\n        // @todo add support for shapes\n        // symbolShape = LegendSvgItem.defaultProps.symbolShape,\n\n        theme,\n    }: LegendCanvasProps\n) => {\n    const { width, height, padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    setCanvasFont(ctx, theme.legends.text)\n\n    data.forEach((d, i) => {\n        const itemX = i * xStep + padding.left\n        const itemY = i * yStep + padding.top\n\n        const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout(\n            {\n                direction: itemDirection,\n                justify,\n                symbolSize,\n                symbolSpacing,\n                width: itemWidth,\n                height: itemHeight,\n            }\n        )\n\n        ctx.fillStyle = d.color ?? 'black'\n        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize)\n\n        ctx.textAlign = textAlignMapping[labelAnchor]\n        if (labelAlignment === 'central') {\n            ctx.textBaseline = 'middle'\n        }\n\n        drawCanvasText(\n            ctx,\n            {\n                ...theme.legends.text,\n                fill: itemTextColor ?? theme.legends.text.fill,\n            },\n            String(d.label),\n            itemX + labelX,\n            itemY + labelY\n        )\n    })\n\n    ctx.restore()\n}\n\nexport const renderContinuousColorLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        containerWidth,\n        containerHeight,\n        anchor,\n        translateX = 0,\n        translateY = 0,\n        scale,\n        length = continuousColorsLegendDefaults.length,\n        thickness = continuousColorsLegendDefaults.thickness,\n        direction = continuousColorsLegendDefaults.direction,\n        ticks: _ticks,\n        tickPosition = continuousColorsLegendDefaults.tickPosition,\n        tickSize = continuousColorsLegendDefaults.tickSize,\n        tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n        tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n        tickFormat = continuousColorsLegendDefaults.tickFormat,\n        title,\n        titleAlign = continuousColorsLegendDefaults.titleAlign,\n        titleOffset = continuousColorsLegendDefaults.titleOffset,\n        theme,\n    }: AnchoredContinuousColorsLegendProps & {\n        theme: Theme\n    }\n) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks: _ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const initialStyles = {\n        font: ctx.font,\n        textAlign: ctx.textAlign,\n        textBaseline: ctx.textBaseline,\n    }\n    ctx.save()\n\n    ctx.translate(x, y)\n\n    const gradient = ctx.createLinearGradient(\n        gradientX1 * width,\n        gradientY1 * height,\n        gradientX2 * width,\n        gradientY2 * height\n    )\n    colorStops.forEach(colorStop => {\n        gradient.addColorStop(colorStop.offset, colorStop.stopColor)\n    })\n\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n\n    setCanvasFont(ctx, theme.legends.ticks.text)\n\n    const tickLineWidth = theme.legends.ticks.line.strokeWidth ?? 0\n    const shouldRenderTickLine = typeof tickLineWidth !== 'string' && tickLineWidth > 0\n    ticks.forEach(tick => {\n        if (shouldRenderTickLine) {\n            ctx.lineWidth = tickLineWidth\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n            ctx.lineCap = 'square'\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x1, tick.y1)\n            ctx.lineTo(tick.x2, tick.y2)\n            ctx.stroke()\n        }\n\n        ctx.textAlign = tick.textHorizontalAlign === 'middle' ? 'center' : tick.textHorizontalAlign\n        ctx.textBaseline = tick.textVerticalAlign === 'central' ? 'middle' : tick.textVerticalAlign\n\n        drawCanvasText(ctx, theme.legends.ticks.text, tick.text, tick.textX, tick.textY)\n    })\n\n    if (titleText) {\n        ctx.save()\n        ctx.translate(titleX, titleY)\n        ctx.rotate(degreesToRadians(titleRotation))\n\n        setCanvasFont(ctx, theme.legends.title.text)\n        ctx.textAlign = titleHorizontalAlign === 'middle' ? 'center' : titleHorizontalAlign\n        ctx.textBaseline = titleVerticalAlign\n\n        drawCanvasText(ctx, theme.legends.title.text, titleText)\n\n        ctx.restore()\n    }\n\n    ctx.restore()\n\n    ctx.font = initialStyles.font\n    ctx.textAlign = initialStyles.textAlign\n    ctx.textBaseline = initialStyles.textBaseline\n}\n","import { useMemo } from 'react'\n\ntype Scale = {\n    (value: number): number\n    invertExtent: (value: number) => [number, number]\n    range: () => number[]\n}\n\nexport const useQuantizeColorScaleLegendData = ({\n    scale,\n    domain: overriddenDomain,\n    reverse = false,\n    valueFormat = v => v,\n    separator = ' - ',\n}: {\n    scale: Scale\n    domain?: number[]\n    reverse?: boolean\n    valueFormat?: <T, U>(value: T) => T | U\n    separator?: string\n}) => {\n    return useMemo(() => {\n        const domain = overriddenDomain ?? scale.range()\n\n        const items = domain.map((domainValue, index) => {\n            const [start, end] = scale.invertExtent(domainValue)\n\n            return {\n                id: domainValue,\n                index,\n                extent: [start, end],\n                label: `${valueFormat(start)}${separator}${valueFormat(end)}`,\n                value: scale(start),\n                color: domainValue,\n            }\n        })\n\n        if (reverse) items.reverse()\n\n        return items\n    }, [overriddenDomain, scale, reverse, separator, valueFormat])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}