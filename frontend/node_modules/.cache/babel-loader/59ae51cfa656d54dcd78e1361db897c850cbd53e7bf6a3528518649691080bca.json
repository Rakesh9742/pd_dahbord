{"ast":null,"code":"import n from \"lodash/uniq.js\";\nimport t from \"lodash/uniqBy.js\";\nimport e from \"lodash/sortBy.js\";\nimport r from \"lodash/last.js\";\nimport i from \"lodash/isDate.js\";\nimport { utcParse as a, timeParse as o } from \"d3-time-format\";\nimport { scaleLinear as u, scalePoint as c, scaleBand as s, scaleUtc as d, scaleTime as m, scaleLog as f, scaleSymlog as l } from \"d3-scale\";\nimport { interpolateRound as v, interpolateNumber as p } from \"d3-interpolate\";\nimport { timeInterval as y, timeMillisecond as h, utcMillisecond as g, timeSecond as x, utcSecond as k, timeMinute as T, utcMinute as b, timeHour as M, utcHour as w, timeWeek as E, utcWeek as S, timeSunday as C, utcSunday as U, timeMonday as j, utcMonday as D, timeTuesday as O, utcTuesday as H, timeWednesday as R, utcWednesday as V, timeThursday as q, utcThursday as A, timeFriday as B, utcFriday as F, timeSaturday as N, utcSaturday as z, timeMonth as I, utcMonth as P, timeYear as $, utcYear as G } from \"d3-time\";\nfunction J() {\n  return J = Object.assign ? Object.assign.bind() : function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var e = arguments[t];\n      for (var r in e) ({}).hasOwnProperty.call(e, r) && (n[r] = e[r]);\n    }\n    return n;\n  }, J.apply(null, arguments);\n}\nvar K = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"],\n  L = [function (n) {\n    return n.setMilliseconds(0);\n  }, function (n) {\n    return n.setSeconds(0);\n  }, function (n) {\n    return n.setMinutes(0);\n  }, function (n) {\n    return n.setHours(0);\n  }, function (n) {\n    return n.setDate(1);\n  }, function (n) {\n    return n.setMonth(0);\n  }],\n  Q = {\n    millisecond: [],\n    second: L.slice(0, 1),\n    minute: L.slice(0, 2),\n    hour: L.slice(0, 3),\n    day: L.slice(0, 4),\n    month: L.slice(0, 5),\n    year: L.slice(0, 6)\n  },\n  W = function (n) {\n    return function (t) {\n      return Q[n].forEach(function (n) {\n        n(t);\n      }), t;\n    };\n  },\n  X = function (n) {\n    var t = n.format,\n      e = void 0 === t ? \"native\" : t,\n      r = n.precision,\n      i = void 0 === r ? \"millisecond\" : r,\n      u = n.useUTC,\n      c = void 0 === u || u,\n      s = W(i);\n    return function (n) {\n      if (void 0 === n) return n;\n      if (\"native\" === e || n instanceof Date) return s(n);\n      var t = c ? a(e) : o(e);\n      return s(t(n));\n    };\n  },\n  Y = {\n    type: \"linear\",\n    min: 0,\n    max: \"auto\",\n    stacked: !1,\n    reverse: !1,\n    clamp: !1,\n    nice: !0,\n    round: !1\n  },\n  Z = function (n, t, e, r) {\n    var i,\n      a,\n      o,\n      c,\n      s = n.min,\n      d = void 0 === s ? Y.min : s,\n      m = n.max,\n      f = void 0 === m ? Y.max : m,\n      l = n.stacked,\n      y = void 0 === l ? Y.stacked : l,\n      h = n.reverse,\n      g = void 0 === h ? Y.reverse : h,\n      x = n.clamp,\n      k = void 0 === x ? Y.clamp : x,\n      T = n.nice,\n      b = void 0 === T ? Y.nice : T,\n      M = n.round,\n      w = void 0 === M ? Y.round : M;\n    \"auto\" === d ? i = !0 === y ? null != (a = t.minStacked) ? a : 0 : t.min : i = d;\n    \"auto\" === f ? o = !0 === y ? null != (c = t.maxStacked) ? c : 0 : t.max : o = f;\n    var E = u().range(\"x\" === r ? [0, e] : [e, 0]).interpolate(w ? v : p).domain(g ? [o, i] : [i, o]).clamp(k);\n    return !0 === b ? E.nice() : \"number\" == typeof b && E.nice(b), _(E, y);\n  },\n  _ = function (n, t) {\n    void 0 === t && (t = !1);\n    var e = n;\n    return e.type = \"linear\", e.stacked = t, e;\n  },\n  nn = function (n, t, e) {\n    var r = c().range([0, e]).domain(t.all);\n    return r.type = \"point\", r;\n  },\n  tn = function (n) {\n    var t = n;\n    return t.type = \"point\", t;\n  },\n  en = {\n    type: \"band\",\n    round: !1\n  },\n  rn = function (n, t, e, r) {\n    var i = n.round,\n      a = void 0 === i ? en.round : i,\n      o = s().range(\"x\" === r ? [0, e] : [e, 0]).domain(t.all).round(a);\n    return an(o);\n  },\n  an = function (n) {\n    var t = n;\n    return t.type = \"band\", t;\n  },\n  on = {\n    type: \"time\",\n    format: \"native\",\n    precision: \"millisecond\",\n    min: \"auto\",\n    max: \"auto\",\n    useUTC: !0,\n    nice: !1\n  },\n  un = function (n, t, e) {\n    var r,\n      i,\n      a = n.format,\n      o = void 0 === a ? on.format : a,\n      u = n.precision,\n      c = void 0 === u ? on.precision : u,\n      s = n.min,\n      f = void 0 === s ? on.min : s,\n      l = n.max,\n      v = void 0 === l ? on.max : l,\n      p = n.useUTC,\n      y = void 0 === p ? on.useUTC : p,\n      h = n.nice,\n      g = void 0 === h ? on.nice : h,\n      x = X({\n        format: o,\n        precision: c,\n        useUTC: y\n      });\n    r = \"auto\" === f ? x(t.min) : \"native\" !== o ? x(f) : f, i = \"auto\" === v ? x(t.max) : \"native\" !== o ? x(v) : v;\n    var k = y ? d() : m();\n    k.range([0, e]), r && i && k.domain([r, i]), !0 === g ? k.nice() : \"object\" != typeof g && \"number\" != typeof g || k.nice(g);\n    var T = k;\n    return T.type = \"time\", T.useUTC = y, T;\n  },\n  cn = {\n    type: \"log\",\n    base: 10,\n    min: \"auto\",\n    max: \"auto\",\n    round: !1,\n    reverse: !1,\n    nice: !0\n  },\n  sn = function (n, t, e, r) {\n    var i,\n      a = n.base,\n      o = void 0 === a ? cn.base : a,\n      u = n.min,\n      c = void 0 === u ? cn.min : u,\n      s = n.max,\n      d = void 0 === s ? cn.max : s,\n      m = n.round,\n      l = void 0 === m ? cn.round : m,\n      v = n.reverse,\n      p = void 0 === v ? cn.reverse : v,\n      y = n.nice,\n      h = void 0 === y ? cn.nice : y;\n    if (t.all.some(function (n) {\n      return 0 === n;\n    })) throw new Error(\"a log scale domain must not include or cross zero\");\n    var g,\n      x,\n      k = !1;\n    if (t.all.filter(function (n) {\n      return null != n;\n    }).forEach(function (n) {\n      k || (void 0 === i ? i = Math.sign(n) : Math.sign(n) !== i && (k = !0));\n    }), k) throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n    g = \"auto\" === c ? t.min : c, x = \"auto\" === d ? t.max : d;\n    var T = f().base(o),\n      b = \"x\" === r ? [0, e] : [e, 0];\n    !0 === l ? T.rangeRound(b) : T.range(b), !0 === p ? T.domain([x, g]) : T.domain([g, x]), !0 === h ? T.nice() : \"number\" == typeof h && T.nice(h);\n    var M = T;\n    return M.type = \"log\", M;\n  },\n  dn = {\n    type: \"symlog\",\n    constant: 1,\n    min: \"auto\",\n    max: \"auto\",\n    round: !1,\n    reverse: !1,\n    nice: !0\n  },\n  mn = function (n, t, e, r) {\n    var i,\n      a,\n      o = n.constant,\n      u = void 0 === o ? dn.constant : o,\n      c = n.min,\n      s = void 0 === c ? dn.min : c,\n      d = n.max,\n      m = void 0 === d ? dn.max : d,\n      f = n.round,\n      v = void 0 === f ? dn.round : f,\n      p = n.reverse,\n      y = void 0 === p ? dn.reverse : p,\n      h = n.nice,\n      g = void 0 === h ? dn.nice : h;\n    i = \"auto\" === s ? t.min : s, a = \"auto\" === m ? t.max : m;\n    var x = l().constant(u),\n      k = \"x\" === r ? [0, e] : [e, 0];\n    !0 === v ? x.rangeRound(k) : x.range(k), !0 === y ? x.domain([a, i]) : x.domain([i, a]), !0 === g ? x.nice() : \"number\" == typeof g && x.nice(g);\n    var T = x;\n    return T.type = \"symlog\", T;\n  },\n  fn = function (n) {\n    return \"x\" === n ? \"y\" : \"x\";\n  },\n  ln = function (n, t) {\n    return n === t;\n  },\n  vn = function (n, t) {\n    return n.getTime() === t.getTime();\n  };\nfunction pn(n, t, e, r) {\n  switch (n.type) {\n    case \"linear\":\n      return Z(n, t, e, r);\n    case \"point\":\n      return nn(0, t, e);\n    case \"band\":\n      return rn(n, t, e, r);\n    case \"time\":\n      return un(n, t, e);\n    case \"log\":\n      return sn(n, t, e, r);\n    case \"symlog\":\n      return mn(n, t, e, r);\n    default:\n      throw new Error(\"invalid scale spec\");\n  }\n}\nvar yn = function (n, t, e) {\n    var r;\n    if (\"stacked\" in e && e.stacked) {\n      var i = n.data[\"x\" === t ? \"xStacked\" : \"yStacked\"];\n      return null == i ? null : e(i);\n    }\n    return null != (r = e(n.data[t])) ? r : null;\n  },\n  hn = function (n, t, e, r, i) {\n    var a = n.map(function (n) {\n        return function (n) {\n          return J({}, n, {\n            data: n.data.map(function (n) {\n              return {\n                data: J({}, n)\n              };\n            })\n          });\n        }(n);\n      }),\n      o = gn(a, t, e);\n    \"stacked\" in t && !0 === t.stacked && Tn(o, a), \"stacked\" in e && !0 === e.stacked && bn(o, a);\n    var u = pn(t, o.x, r, \"x\"),\n      c = pn(e, o.y, i, \"y\"),\n      s = a.map(function (n) {\n        return J({}, n, {\n          data: n.data.map(function (n) {\n            return J({}, n, {\n              position: {\n                x: yn(n, \"x\", u),\n                y: yn(n, \"y\", c)\n              }\n            });\n          })\n        });\n      });\n    return J({}, o, {\n      series: s,\n      xScale: u,\n      yScale: c\n    });\n  },\n  gn = function (n, t, e) {\n    return {\n      x: xn(n, \"x\", t),\n      y: xn(n, \"y\", e)\n    };\n  },\n  xn = function (i, a, o, u) {\n    var c = void 0 === u ? {} : u,\n      s = c.getValue,\n      d = void 0 === s ? function (n) {\n        return n.data[a];\n      } : s,\n      m = c.setValue,\n      f = void 0 === m ? function (n, t) {\n        n.data[a] = t;\n      } : m;\n    if (\"linear\" === o.type) i.forEach(function (n) {\n      n.data.forEach(function (n) {\n        var t = d(n);\n        t && f(n, parseFloat(String(t)));\n      });\n    });else if (\"time\" === o.type && \"native\" !== o.format) {\n      var l = X(o);\n      i.forEach(function (n) {\n        n.data.forEach(function (n) {\n          var t = d(n);\n          t && f(n, l(t));\n        });\n      });\n    }\n    var v = [];\n    switch (i.forEach(function (n) {\n      n.data.forEach(function (n) {\n        v.push(d(n));\n      });\n    }), o.type) {\n      case \"linear\":\n        var p = e(n(v).filter(function (n) {\n          return null !== n;\n        }), function (n) {\n          return n;\n        });\n        return {\n          all: p,\n          min: Math.min.apply(Math, p),\n          max: Math.max.apply(Math, p)\n        };\n      case \"time\":\n        var y = t(v, function (n) {\n          return n.getTime();\n        }).slice(0).sort(function (n, t) {\n          return t.getTime() - n.getTime();\n        }).reverse();\n        return {\n          all: y,\n          min: y[0],\n          max: r(y)\n        };\n      default:\n        var h = n(v);\n        return {\n          all: h,\n          min: h[0],\n          max: r(h)\n        };\n    }\n  },\n  kn = function (n, t, e) {\n    var a = fn(n),\n      o = [];\n    t[a].all.forEach(function (t) {\n      var u = i(t) ? vn : ln,\n        c = [];\n      e.forEach(function (e) {\n        var i = e.data.find(function (n) {\n            return u(n.data[a], t);\n          }),\n          s = null,\n          d = null;\n        if (void 0 !== i) {\n          if (null !== (s = i.data[n])) {\n            var m = r(c);\n            void 0 === m ? d = s : null !== m && (d = m + s);\n          }\n          i.data[\"x\" === n ? \"xStacked\" : \"yStacked\"] = d;\n        }\n        c.push(d), null !== d && o.push(d);\n      });\n    }), t[n].minStacked = Math.min.apply(Math, o), t[n].maxStacked = Math.max.apply(Math, o);\n  },\n  Tn = function (n, t) {\n    return kn(\"x\", n, t);\n  },\n  bn = function (n, t) {\n    return kn(\"y\", n, t);\n  },\n  Mn = function (n) {\n    var t = n.bandwidth();\n    if (0 === t) return n;\n    var e = t / 2;\n    return n.round() && (e = Math.round(e)), function (t) {\n      var r;\n      return (null != (r = n(t)) ? r : 0) + e;\n    };\n  },\n  wn = {\n    millisecond: [h, g],\n    second: [x, k],\n    minute: [T, b],\n    hour: [M, w],\n    day: [y(function (n) {\n      return n.setHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setDate(n.getDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    }), y(function (n) {\n      return n.setUTCHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setUTCDate(n.getUTCDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    })],\n    week: [E, S],\n    sunday: [C, U],\n    monday: [j, D],\n    tuesday: [O, H],\n    wednesday: [R, V],\n    thursday: [q, A],\n    friday: [B, F],\n    saturday: [N, z],\n    month: [I, P],\n    year: [$, G]\n  },\n  En = Object.keys(wn),\n  Sn = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\" + En.join(\"|\") + \")s?$\", \"i\"),\n  Cn = function (n, t) {\n    if (Array.isArray(t)) return t;\n    if (\"string\" == typeof t && \"useUTC\" in n) {\n      var e = t.match(Sn);\n      if (e) {\n        var r = e[1],\n          i = e[2],\n          a = wn[i][n.useUTC ? 1 : 0];\n        if (\"day\" === i) {\n          var o,\n            u,\n            c = n.domain(),\n            s = c[0],\n            d = c[1],\n            m = new Date(d);\n          return m.setDate(m.getDate() + 1), null != (o = null == (u = a.every(Number(null != r ? r : 1))) ? void 0 : u.range(s, m)) ? o : [];\n        }\n        if (void 0 === r) return n.ticks(a);\n        var f = a.every(Number(r));\n        if (f) return n.ticks(f);\n      }\n      throw new Error(\"Invalid tickValues: \" + t);\n    }\n    if (\"ticks\" in n) {\n      if (void 0 === t) return n.ticks();\n      if (\"number\" == typeof (l = t) && isFinite(l) && Math.floor(l) === l) return n.ticks(t);\n    }\n    var l;\n    return n.domain();\n  },\n  Un = function (n) {\n    return \"linear\" === n.type || \"log\" === n.type || \"symlog\" === n.type;\n  };\nexport { en as bandScaleDefaults, an as castBandScale, _ as castLinearScale, tn as castPointScale, Mn as centerScale, vn as compareDateValues, ln as compareValues, pn as computeScale, hn as computeXYScalesForSeries, rn as createBandScale, X as createDateNormalizer, Z as createLinearScale, sn as createLogScale, nn as createPointScale, W as createPrecisionMethod, mn as createSymlogScale, un as createTimeScale, xn as generateSeriesAxis, gn as generateSeriesXY, fn as getOtherAxis, Cn as getScaleTicks, Un as isReversibleScaleSpec, Y as linearScaleDefaults, cn as logScaleDefaults, L as precisionCutOffs, Q as precisionCutOffsByType, kn as stackAxis, dn as symlogScaleDefaults, K as timePrecisions, on as timeScaleDefaults };","map":{"version":3,"names":["K","L","n","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","Q","millisecond","second","slice","minute","hour","day","month","year","W","createPrecisionMethod","t","forEach","X","createDateNormalizer","format","e","r","precision","i","u","useUTC","c","s","Date","a","o","Y","type","min","max","stacked","reverse","clamp","nice","round","Z","createLinearScale","d","m","f","l","y","h","g","x","k","T","b","M","w","minStacked","maxStacked","E","range","interpolate","v","p","domain","_","castLinearScale","nn","createPointScale","all","tn","castPointScale","en","rn","createBandScale","an","castBandScale","on","un","createTimeScale","cn","base","sn","createLogScale","some","Error","filter","Math","sign","rangeRound","dn","constant","mn","createSymlogScale","fn","getOtherAxis","ln","compareValues","vn","compareDateValues","getTime","pn","yn","getDatumAxisPosition","data","hn","computeXYScalesForSeries","map","J","gn","Tn","bn","position","series","xScale","yScale","generateSeriesXY","xn","generateSeriesAxis","getValue","setValue","parseFloat","String","push","apply","sort","kn","stackAxis","find","stackX","stackY","Mn","centerScale","bandwidth","wn","getDate","floor","setUTCHours","setUTCDate","getUTCDate","week","S","sunday","C","U","monday","j","D","tuesday","O","H","wednesday","R","V","thursday","q","A","friday","B","F","saturday","N","z","I","P","$","G","En","Object","keys","Sn","RegExp","join","Cn","getScaleTicks","Array","isArray","match","every","Number","ticks","isFinite","Un","isReversibleScaleSpec","bandScaleDefaults","computeScale","linearScaleDefaults","logScaleDefaults","precisionCutOffs","precisionCutOffsByType","symlogScaleDefaults","timePrecisions","timeScaleDefaults"],"sources":["C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\timeHelpers.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\linearScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\pointScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\bandScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\timeScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\logScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\symlogScale.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\compute.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\ticks.ts","C:\\Users\\2020r\\dashboard\\frontend\\node_modules\\@nivo\\scales\\src\\types.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { interpolateRound, interpolateNumber } from 'd3-interpolate'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const linearScaleDefaults: Required<ScaleLinearSpec> = {\n    type: 'linear',\n    min: 0,\n    max: 'auto',\n    stacked: false,\n    reverse: false,\n    clamp: false,\n    nice: true,\n    round: false,\n}\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = linearScaleDefaults.min,\n        max = linearScaleDefaults.max,\n        stacked = linearScaleDefaults.stacked,\n        reverse = linearScaleDefaults.reverse,\n        clamp = linearScaleDefaults.clamp,\n        nice = linearScaleDefaults.nice,\n        round = linearScaleDefaults.round,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? (data.minStacked ?? 0) : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? (data.maxStacked ?? 0) : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .interpolate(round ? interpolateRound : interpolateNumber)\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const bandScaleDefaults: Required<ScaleBandSpec> = {\n    type: 'band',\n    round: false,\n}\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = bandScaleDefaults.round }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const timeScaleDefaults: Required<ScaleTimeSpec> = {\n    type: 'time',\n    format: 'native',\n    precision: 'millisecond',\n    min: 'auto',\n    max: 'auto',\n    useUTC: true,\n    nice: false,\n}\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = timeScaleDefaults.format,\n        precision = timeScaleDefaults.precision,\n        min = timeScaleDefaults.min,\n        max = timeScaleDefaults.max,\n        useUTC = timeScaleDefaults.useUTC,\n        nice = timeScaleDefaults.nice,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const logScaleDefaults: Required<ScaleLogSpec> = {\n    type: 'log',\n    base: 10,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createLogScale = (\n    {\n        base = logScaleDefaults.base,\n        min = logScaleDefaults.min,\n        max = logScaleDefaults.max,\n        round = logScaleDefaults.round,\n        reverse = logScaleDefaults.reverse,\n        nice = logScaleDefaults.nice,\n    }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>().base(base)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    // @ts-expect-error not sure why this is not working, it's available for symlog.\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const symlogScaleDefaults: Required<ScaleSymlogSpec> = {\n    type: 'symlog',\n    constant: 1,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createSymlogScale = (\n    {\n        constant = symlogScaleDefaults.constant,\n        min = symlogScaleDefaults.min,\n        max = symlogScaleDefaults.max,\n        round = symlogScaleDefaults.round,\n        reverse = symlogScaleDefaults.reverse,\n        nice = symlogScaleDefaults.nice,\n    }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>().constant(constant)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq.js'\nimport uniqBy from 'lodash/uniqBy.js'\nimport sortBy from 'lodash/sortBy.js'\nimport last from 'lodash/last.js'\nimport isDate from 'lodash/isDate.js'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date | null\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date | null\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: readonly D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Exclude<Input, null>>(spec, data, size)\n        case 'band':\n            return createBandScale<Exclude<Input, null>>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\n/**\n * Band and point scales are not centered, meaning the ticks would\n * be positioned at the beginning of each step; however, we want\n * them to be centered for each step.\n */\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable,\n            // however, local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n","import {\n    ScaleLinear as D3ScaleLinear,\n    ScalePoint as D3ScalePoint,\n    ScaleBand as D3ScaleBand,\n    ScaleLogarithmic as D3ScaleLogarithmic,\n    ScaleSymLog as D3ScaleSymLog,\n    ScaleTime as D3ScaleTime,\n} from 'd3-scale'\nimport { TIME_PRECISION } from './timeHelpers'\n\nexport type ScaleAxis = 'x' | 'y'\nexport type OtherScaleAxis<Axis extends ScaleAxis> = Axis extends 'x' ? 'y' : 'x'\n\nexport type NumericValue = { valueOf(): number }\nexport type StringValue = { toString(): string }\nexport type ScaleValue = NumericValue | StringValue | Date | null\n\nexport interface ScaleTypeToSpec {\n    linear: ScaleLinearSpec\n    log: ScaleLogSpec\n    symlog: ScaleSymlogSpec\n    point: ScalePointSpec\n    band: ScaleBandSpec\n    time: ScaleTimeSpec\n}\n\nexport type ScaleType = keyof ScaleTypeToSpec\nexport type ScaleSpec = ScaleTypeToSpec[keyof ScaleTypeToSpec]\n\nexport type ReversibleScaleSpec = ScaleLinearSpec | ScaleLogSpec | ScaleSymlogSpec\n\nexport const isReversibleScaleSpec = (scaleSpec: ScaleSpec): scaleSpec is ReversibleScaleSpec => {\n    return scaleSpec.type === 'linear' || scaleSpec.type === 'log' || scaleSpec.type === 'symlog'\n}\n\nexport interface ScaleTypeToScale<Input, Output> {\n    linear: Input extends NumericValue ? ScaleLinear<Output> : never\n    log: Input extends NumericValue ? ScaleLog : never\n    symlog: Input extends NumericValue ? ScaleSymlog : never\n    point: Input extends StringValue ? ScalePoint<Input> : never\n    band: Input extends StringValue ? ScaleBand<Input> : never\n    time: Input extends StringValue | Date ? ScaleTime<Input> : never\n}\n\nexport type Scale<Input, Output> = ScaleTypeToScale<Input, Output>[keyof ScaleTypeToScale<\n    Input,\n    Output\n>]\n\nexport type ScaleLinearSpec = {\n    type: 'linear'\n    min?: 'auto' | number\n    max?: 'auto' | number\n    stacked?: boolean\n    reverse?: boolean\n    clamp?: boolean\n    nice?: boolean | number\n    round?: boolean\n}\nexport interface ScaleLinear<Output> extends D3ScaleLinear<number, Output, never> {\n    type: 'linear'\n    stacked: boolean\n}\n\nexport interface ScaleLogSpec {\n    type: 'log'\n    base?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleLog extends D3ScaleLogarithmic<number, number> {\n    type: 'log'\n}\n\nexport interface ScaleSymlogSpec {\n    type: 'symlog'\n    constant?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleSymlog extends D3ScaleSymLog<number, number> {\n    type: 'symlog'\n}\n\nexport type ScalePointSpec = {\n    type: 'point'\n}\nexport interface ScalePoint<Input extends StringValue> extends D3ScalePoint<Input> {\n    type: 'point'\n}\n\nexport type ScaleBandSpec = {\n    type: 'band'\n    round?: boolean\n}\nexport interface ScaleBand<Input extends StringValue> extends D3ScaleBand<Input> {\n    type: 'band'\n}\n\nexport type ScaleTimeSpec = {\n    type: 'time'\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    min?: 'auto' | Date | string\n    max?: 'auto' | Date | string\n    useUTC?: boolean\n    nice?: boolean\n}\n\nexport interface ScaleTime<Input> extends D3ScaleTime<Input, number> {\n    type: 'time'\n    useUTC: boolean\n}\n\nexport type AnyScale = Scale<any, any>\n\nexport type ScaleWithBandwidth = ScaleBand<any> | ScalePoint<any>\n\nexport type Series<XValue extends ScaleValue, YValue extends ScaleValue> = {\n    data: {\n        data: {\n            x: XValue | null\n            y: YValue | null\n        }\n    }[]\n}[]\n\n// A serie containing data for a specific axis\nexport type SerieAxis<Axis extends ScaleAxis, Value extends ScaleValue> = {\n    data: {\n        data: Record<Axis, Value | null>\n    }[]\n}[]\n\nexport type ComputedSerieAxis<Value extends ScaleValue> = {\n    all: readonly Value[]\n    min: Value\n    minStacked?: Value\n    max: Value\n    maxStacked?: Value\n}\n\nexport type TicksSpec<Value extends ScaleValue> =\n    // exact number of ticks, please note that\n    // depending on the current range of values,\n    // you might not get this exact count\n    | number\n    // string is used for Date based scales,\n    // it can express a time interval,\n    // for example: every 2 weeks\n    | string\n    // override scale ticks with custom explicit values\n    | readonly Value[]\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}